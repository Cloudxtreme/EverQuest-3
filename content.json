{"meta":{"title":"后乐","subtitle":"柴门闻犬吠，风雪夜归人","description":null,"author":"ZiZhi Cao","url":"https://sophoraflower.github.io/EverQuest"},"pages":[{"title":"About Hueman","date":"2018-01-15T11:49:53.883Z","updated":"2018-01-15T11:49:53.883Z","comments":true,"path":"about/index.html","permalink":"https://sophoraflower.github.io/EverQuest/about/index.html","excerpt":"","text":"Probably the most beautiful theme for Hexo. Preview This theme is ported from AlxMedia‘s the WordPress theme Hueman.Special thanks to AlxMedia, who designed the original theme Hueman for wordpress.View DocumentationIt is strongly recommended that you read the docs before using Hueman. FeaturesResponsive LayoutHueman knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Categories inside Main MenuHueman inserts your blog categories into main menu in the header section. You can enable/disable this feature in menu setting. Self-hosted Insite Search EngineWith the help of Insight Search, you can search anything inside your site without any third-party plugin. Custom Comment ServicesHueman supports several comment services, give you better choices to communicate with your readers. ThumbnailHueman uses the thumbnail front-matter option to set the thumbnail for a post. If the post does not have a thumbnail option, Hueman will find the first image in the post as the thumbnail. You can enable/disable this feature in thumbnail setting. Code HighlightHueman has more than 60 themes imported from Highlight.js, and it is very easy to customize your own highlight theme. lightgalleryHueman uses lightgallery.js to showcase your photos. Just enable it in your configuration, and that’s all! SidebarHueman provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. And so many new features to be explored…View Documentation"}],"posts":[{"title":"Java进阶知识汇总","slug":"Java进阶知识汇总","date":"2018-01-31T14:38:00.000Z","updated":"2018-01-31T14:43:19.670Z","comments":true,"path":"2018/0131/Java进阶知识汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2018/0131/Java进阶知识汇总/","excerpt":"","text":"Java 类与对象 面向对象：体现的是人所关注对象的信息聚集在了一个具体的物体上，通过对象的属性和行为来了解对象 类：封装对象的属性和行为的载体，具有相同属性和方法（行为）的对象的集合 类就是对象的抽象(或者模板)，对象就是类的具体（或者实例） 定义类： 12345678910public class 类名&#123; //定义属性部分（成员变量） 属性1的类型 属性1; 属性2的类型 属性2; ... //定义方法部分 方法1; 方法2; ...&#125; 类型变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为static类型。 构造方法： 语法格式 1234// 与类名相同，可以指定参数，没有返回值public 构造方法名()&#123; // 初始化代码&#125; 12345678910111213public class People &#123; // 属性（成员变量） double height; int age; // 构造函数，初始化属性 public People (double a, int b)&#123; height = a; age = b; &#125;&#125;// 创建对象People MiaoMiao = new People(174, 29); 在定义类的时候没有写构造方法，系统会默认给我们生成一个无参构造方法 构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法 对象 创建对象 1类名 对象名 = new 类名(); 使用对象 12345// 引用对象属性对象名.属性// 引用对象方法对象名.方法 作用域：变量的生存期或者作用范围，局部变量有更高的优先级 Java 封装 封装：封装是指，一种将抽象性函式接口的实例细节部份包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制，通过该类提供的方法来实现对隐藏信息的操作和访问 只能通过规定的方法访问数据 隐藏类的实例细节，方便修改和实现 实现 封装 123456789101112public class People &#123; private double height; // 设置getter和setter方法 public double getHeight()&#123; return height; &#125; public void setHeight(double newHeight)&#123; height = newHeight; &#125;&#125; 调用 1234567public class OldPeople &#123; private static void main(String[] args)&#123; People MiaoMiao = new People(); MiaoMiao.setHeight(175.0); System.out.println(\"MiaoMiao的身高是\"+MiaoMiao.getHeight()); &#125; &#125; 包机制：区别类名的命名空间 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用 包采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类 定义和使用： 123package 包名import com.zhanqi.zhuboimport com.zhanqi.* 访问修饰符 private修饰的属性或者方法，只能在当前类中访问或者使用 默认是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用 protected修饰的属性或者方法，对同一包内的类和所有子类可见 public修饰的属性或者方法，对所有类可见。 this 关键字：代表当前对象 123public void setAge(int age) &#123; this.age = age;&#125; 内部类 作用 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类 内部类的方法可以直接访问外部类的所有数据，包括私有的数据 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便 内部类允许继承多个非接口类型 内部类的成员变量/方法名可以和外部类的相同 成员内部类、静态内部类、局部内部类、匿名内部类 参考文章： Java内部类的使用小结 java中的匿名内部类总结 静态内部类和非静态内部类的区别 ​ Java 继承 继承定义 继承可以看成是类与类之间的衍生关系，父类更通用，子类更具体 创建一个类来继承某一个类： 12345678class 子类 extends 父类// E.Gpublic class Animal &#123; public int legNum; public void bark()&#123; System.out.println(\"animal crying!\") &#125;&#125; 继承的特点： 子类拥有父类除private以外的所有属性和方法 子类可以拥有自己的属性和方法 子类可以重写实现父类的方法 Java 中的继承是单继承，一个类只有一个父类 方法重写 &emsp;&emsp;方法重写时需要注意，重写的方法一定要与原父类的方法语法保持一致，比如返回值类型，参数类型及个数，和方法名都必须一致。 123456public class Dog extends Animal &#123; //重写父类的bark方法 public void bark() &#123; System.out.println(\"汪！汪！汪！\"); &#125; &#125; 12345678910public class Test&#123; public static void main(String args[])&#123; Animal a = new Animal(); Dog d = new Dog(); Animal b = new Dog(); a.bark(); // 执行 Animal 类的方法 d.bark(); // 执行 Dog 类的方法 b.bark(); // 执行 Dog 类的方法 &#125;&#125; 继承的初始化顺序 &emsp;&emsp;继承的初始化顺序是先初始化父类再初始化子类。 final 关键字：可以修饰类、方法、属性和变量 final 修饰类，则该类不允许被继承，为最终类 final 修饰方法，则该方法不允许被覆盖（重写） final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一） super 关键字：在子类内部使用，代表父类对象 访问父类的属性 super.属性名 访问父类的方法 super.bark() 子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super() Java 多态&emsp;&emsp;多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 &emsp;&emsp;通俗地讲，只通过父类就能够引用不同的子类，这就是多态，我们只有在运行的时候才会知道引用变量所指向的具体实例对象。 向上转型 12345// 除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能。但是对于只存在于子类的方法和// 属性就不能获取。// 向上转型，在运行时，会遗忘子类对象中与父类对象中不同的方法，也会覆盖与父类中相同的方法——重写。（方// 法名，参数都相同）Animal b = new Dog(); // b是父类的引用指向的是子类的对象 多态的实现条件 Java 实现多态有三个必要条件：继承、重写和向上转型（即父类引用指向子类对象）。 只有满足上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 多态的实现 重写 抽象类和抽象方法 抽象方法声明： 1abstract void f(); // f()方法是抽象方法，包含抽象方法的类是抽象类 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。也就是说抽象类是约束子类必须要实现哪些方法，而并不关注方法如何去实现 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性 抽象类是限制规定子类必须实现某些方法，但不关注实现细节 实现细节 用 abstract 修饰符定义抽象类 用 abstract 修饰符定义抽象方法，只用声明，不需要实现 包含抽象方法的类就是抽象类 抽象类中可以包含普通的方法，也可以没有抽象方法 抽象类的对象不能直接创建，我们通常是定义引用变量指向子类对象 12345//抽象方法public abstract class TelePhone &#123; public abstract void call(); // 抽象方法,打电话 public abstract void message(); // 抽象方法，发短信&#125; 123456789101112131415161718// 构建子类，并实现抽象方法public class CellPhone extends TelePhone &#123; @Override public void call() &#123; // TODO Auto-generated method stub System.out.println(\"我可以打电话！\"); &#125; @Override public void message() &#123; // TODO Auto-generated method stub System.out.println(\"我可以发短信！\"); &#125; public static void main(String[] args) &#123; CellPhone cp = new CellPhone(); cp.call(); // 我可以打电话！ cp.message(); // 我可以发短信！ &#125;&#125; 接口：完全抽象类，没有提供任何方法体 接口的声明语法格式如下： 123456789101112修饰符 interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125;// E.Ginterface Animal &#123; // int x; // 编译错误,x需要初始化，因为是 static final 类型 int y = 5; public void eat(); public void travel();&#125; 接口不能用于实例化对象 接口中所有的方法是抽象方法 接口成员是 static final 类型 接口支持多继承 多继承实现方式 12345678910111213141516171819202122修饰符 interface A extends 接口1，接口2&#123;&#125;修饰符 class A implements 接口1，接口2&#123;&#125;// E.Gpublic class Cat implements Animal&#123; public void eat()&#123; System.out.println(\"Cat eats\"); &#125; public void travel()&#123; System.out.println(\"Cat travels\"); &#125; public static void main(String[] args) &#123; Cat cat = new Cat(); cat.eat(); // Cat eats cat.travel(); // Cat travels &#125;&#125; 文章参考 Java 多态 Java 接口 Java 多态理解 java提高篇(四)—–理解java的三大特性之多态 ​","categories":[{"name":"Java","slug":"Java","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/"},{"name":"编程基础","slug":"Java/编程基础","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/编程基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://sophoraflower.github.io/EverQuest/tags/java/"}]},{"title":"西湖春雪","slug":"西湖春雪","date":"2018-01-28T18:07:00.000Z","updated":"2018-01-28T18:23:47.738Z","comments":true,"path":"2018/0129/西湖春雪/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2018/0129/西湖春雪/","excerpt":"","text":"西湖春游-2018/01/27 下午","categories":[{"name":"LifeStyle","slug":"LifeStyle","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/"},{"name":"摄影","slug":"LifeStyle/摄影","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/摄影/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://sophoraflower.github.io/EverQuest/tags/摄影/"}]},{"title":"EverQuest-前半年规划","slug":"EverQuest-2018-前半年规划","date":"2018-01-01T10:18:18.000Z","updated":"2018-02-02T17:20:34.972Z","comments":true,"path":"2018/0101/EverQuest-2018-前半年规划/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2018/0101/EverQuest-2018-前半年规划/","excerpt":"","text":"Python 语言学习 《Python核心编程》 Web接口开发 + Django 接口测试（性能）框架整合 + 构建 + 升级 UI 自动测试化框架整合 + 构建 + 升级 …… Java 语言学习 【Java Web 课程】 - 网易云课堂 - （201802-05） - 核心 《Java 8 编程入门官方教程》 《Java 程序设计》- 北京大学 - 中国大学MOOC 《面向对象程序设计——Java语言》 - 浙江大学 - 中国大学MOOC Java相关课程 - 慕课网/实验楼 - 围绕云课堂核心选择性学习 …… 计算机基础 《图解 HTTP》 《SQL 基础教程》 《计算机网络》 《数据结构（Java）》 IT 相关书籍 …… 测试进阶 《Web 接口开发与自动化测试》 《Selenium 2 自动化测试实战 基于Python语言》 《深入理解Android》自动化测试 《全栈性能测试修炼宝典 JMeter实战》 《Fiddler 调试权威指南》 …… 摄影-书法-旅游 《摄影基础》- 电子科技大学 - 中国大学MOOC 《pssx60hs-cu-zh》（佳能SX60HS官方指导） 千岛湖-黄山-XX古镇-XX古村 …… 英语 托业 …… Linux Linux系统（Linux命令行） shell脚本编程大全 健身 八块腹肌 体重（62-65KG） 骑行 …… 读书计划 《中国通史》 《老子新释》 《浪潮之巅》 …… ……","categories":[{"name":"EverQuest","slug":"EverQuest","permalink":"https://sophoraflower.github.io/EverQuest/categories/EverQuest/"}],"tags":[]},{"title":"Java基础练习汇总","slug":"Java基础练习汇总","date":"2017-12-27T14:41:00.000Z","updated":"2018-01-21T23:24:24.769Z","comments":true,"path":"2017/1227/Java基础练习汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/1227/Java基础练习汇总/","excerpt":"","text":"用程序来做计算 温度转换 ​ 写一个将华氏温度转换成摄氏温度的程序，转换的公式是： 1°F = (9/5)*°C + 32 ​ 程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。 提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式： 1(int)x; 输入格式: ​ 一个整数。 输出格式： ​ 一个整数 输入样例： ​ 100 输出样例： ​ 37 解决方案： 1234567891011import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int degreeFa; int centigrade; degreeFa = in.nextInt(); centigrade = (int) (5.0*(degreeFa-32)/9.0); System.out.println(centigrade); &#125;&#125; 猜字游戏 &emsp;&emsp;为什么方法正确的话，100以内的数最多猜7次就够了？ 1234567891011121314151617181920public static void main(String[] args) &#123; for(int num=1; num&lt;=100; num++) &#123; int count = 0; int low = 0; int high = 100; int guess; do &#123; guess=(low+high)/2; if(guess&lt;num) &#123; low=guess+1; &#125;else &#123; high=guess+1; &#125; ++count; System.out.println(\"第\"+count+\"次猜:\"+guess); &#125;while(guess!=num); System.out.println(\"一共猜了\"+count+\"次\"); break; &#125; &#125; 温度转换 写一个将华氏温度转换成摄氏温度的程序，转换的公式是： 1°F = (9/5)*°C + 32 程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。 提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式： 1(int)x; 输入格式: 一个整数。 输出格式： 一个整数 输入样例： 100 输出样例： 37 解决方案： 1234567891011import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int degreeFa; int centigrade; degreeFa = in.nextInt(); centigrade = (int) (5.0*(degreeFa-32)/9.0); System.out.println(centigrade); &#125;&#125; 时间换算 题目内容： UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。 有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。 你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 提醒：要小心跨日的换算。 输入格式: 一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 输出格式： 一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 输入样例： 903 输出样例： 103 解决方案： 123456789101112131415import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int BTJTime = in.nextInt(); int UTCTime; if (BTJTime&gt;=800) &#123; UTCTime = BTJTime-800; System.out.println(UTCTime); &#125; else &#123; UTCTime = BTJTime+1600; System.out.println(UTCTime); &#125; &#125;&#125; 奇偶个数 题目内容： 你的程序要读入一系列正整数数据，输入-1表示输入结束，-1本身不是输入的数据。程序输出读到的数据中的奇数和偶数的个数。 输入格式: 一系列正整数，整数的范围是（0,100000）。如果输入-1则表示输入结束。 输出格式： 两个整数，第一个整数表示读入数据中的奇数的个数，第二个整数表示读入数据中的偶数的个数。两个整数之间以空格分隔。 输入样例： 9 3 4 2 5 7 -1 输出样例： 4 2 解决方案： 12345678910111213141516171819import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int intNumber = in.nextInt(); int evenNumber = 0; int oddNumber = 0; while (intNumber!=-1) &#123; if (intNumber%2 == 0) &#123; evenNumber++; &#125;else &#123; oddNumber++; &#125; intNumber = in.nextInt(); &#125; System.out.println(oddNumber+\" \"+evenNumber); &#125;&#125; 数字特征值 题目内容： 对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。 这里的计算可以用下面的表格来表示： | 数字 | 3 | 4 | 2 | 3 | 1 | 5 || —– | —- | —- | —- | —- | —- | —- || 数位 | 6 | 5 | 4 | 3 | 2 | 1 || 数字奇偶 | 奇 | 偶 | 偶 | 奇 | 奇 | 奇 || 数位奇偶 | 偶 | 奇 | 偶 | 奇 | 偶 | 奇 || 奇偶一致 | 0 | 0 | 1 | 1 | 0 | 1 || 二进制位值 | 32 | 16 | 8 | 4 | 2 | 1 | 按照二进制位值将1的位的位值加起来就得到了结果13。 你的程序要读入一个非负整数，整数的范围是[0,100000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。 提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。 输入格式: 一个非负整数，整数的范围是[0,100000]。 输出格式： 一个整数，表示计算结果。 输入样例： 342315 输出样例： 13 解决方案： 12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int intNumber = in.nextInt(); in.close(); int iNumber = intNumber; int outNumber = 0; // 判断输入数位数 int figureNumber = 0; do &#123; intNumber =intNumber/10; figureNumber =figureNumber+1; &#125; while ( intNumber&gt;0 ); // 数字和数位奇偶对比 while (figureNumber&gt;0) &#123; // 获取数字 int number1 =iNumber%((int)Math.pow(10, figureNumber)); int number =number1/((int)Math.pow(10, figureNumber-1)); int oNumber = 0; if (number%2==0 &amp;&amp; figureNumber%2==0) &#123; oNumber = (int)Math.pow(2, (figureNumber-1)); &#125; else if (number%2!=0 &amp;&amp; figureNumber%2!=0) &#123; oNumber = (int)Math.pow(2, (figureNumber-1)); &#125; else &#123; oNumber = 0; &#125; outNumber +=oNumber; figureNumber--; &#125; System.out.print(outNumber); &#125;&#125; ​ 信号报告 题目内容： 无线电台的RS制信号报告是由三两个部分组成的： R(Readability) 信号可辨度即清晰度. S(Strength) 信号强度即大小. 其中R位于报告第一位，共分5级，用1—5数字表示. 1—Unreadable 2—Barely readable, occasional words distinguishable 3—Readable with considerable difficulty 4—Readable with practically no difficulty 5—Perfectly readable 报告第二位是S，共分九个级别，用1—9中的一位数字表示 1—Faint signals, barely perceptible 2—Very weak signals 3—Weak signals 4—Fair signals 5—Fairly good signals 6—Good signals 7—Moderately strong signals 8—Strong signals 9—Extremely strong signals 现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到59，则输出： 1Extremely strong signals, perfectly readable. 输入格式: 一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是[11,59]，这个范围外的数字不可能出现在测试数据中。 输出格式： 一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。 输入样例： 33 输出样例： 1Weak signals, readable with considerable difficulty. 解决方案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int intNumber = in.nextInt(); in.close(); int firstNumber = intNumber/10; int secondNumber = intNumber%10; switch (secondNumber) &#123; case 1: System.out.print(\"Faint signals, barely perceptible\"); break; case 2: System.out.print(\"Very weak signals\"); break; case 3: System.out.print(\"Weak signals\"); break; case 4: System.out.print(\"Fair signals\"); break; case 5: System.out.print(\"Fairly good signals\"); break; case 6: System.out.print(\"Good signals\"); break; case 7: System.out.print(\"Moderately strong signals\"); break; case 8: System.out.print(\"Strong signals\"); break; case 9: System.out.print(\"Extremely strong signals\"); break; default: System.out.print(\"input error!\"); break; &#125; System.out.print(\", \"); switch (firstNumber) &#123; case 1: System.out.print(\"unreadable\"); break; case 2: System.out.print(\"barely readable, occasional words distinguishable\"); break; case 3: System.out.print(\"readable with considerable difficulty\"); break; case 4: System.out.print(\"readable with practically no difficulty\"); break; case 5: System.out.print(\"perfectly readable\"); break; default: System.out.print(\"input error!\"); break; &#125; System.out.print(\".\"); &#125;&#125; 素数和 题目内容： 我们认为2是第一个素数，3是第二个素数，5是第三个素数，依次类推。 现在，给定两个整数n和m，0&lt;n&lt;=m&lt;=200，你的程序要计算第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。 注意，是第n个素数到第m个素数之间的所有的素数，并不是n和m之间的所有的素数。 输入格式: 两个整数，第一个表示n，第二个表示m。 输出格式： 一个整数，表示第n个素数到第m个素数之间所有的素数的和，包括第n个素数和第m个素数。 输入样例： 2 4 输出样例： 15 解决方案： 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); in.close(); int sum=0, number=0; int x=2, cnt=0; while(n&lt;=0||m&lt;n||m&gt;200) &#123; System.out.print(\"输入不符合，请重新输入：\"); &#125; while ( cnt &lt; m ) &#123; int isPrime = 1; for( int i=2; i&lt;x; i++ ) &#123; if ( x%i == 0 ) &#123; isPrime = 0; break; &#125; &#125; if ( isPrime == 1 )&#123; number = x; cnt++; if( cnt &gt;= n)&#123; sum = sum + number; &#125; &#125; x++; &#125; System.out.print(sum); &#125;&#125; ​ 念整数 题目内容： 你的程序要读入一个整数，范围是[-100000,100000]。然后，用汉语拼音将这个整数的每一位输出出来。 如输入1234，则输出： yi er san si 注意，每个字的拼音之间有一个空格，但是最后的字后面没有空格。当遇到负数时，在输出的开头加上“fu”，如-2341输出为： fu er san si yi 输入格式: 一个整数，范围是[-100000,100000]。 输出格式： 表示这个整数的每一位数字的汉语拼音，每一位数字的拼音之间以空格分隔，末尾没有空格。 输入样例： -30 输出样例： fu san ling 解决方案一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int number = in.nextInt(); in.close(); int digit = 100000; if ( number &lt; 0 ) &#123; System.out.print(\"fu \"); number = -number; &#125; while (digit &gt; 1) &#123; if ( number / digit != 0 ) &#123; break; &#125; digit /= 10; &#125; for ( ; digit &gt; 0; digit /= 10 ) &#123; switch ( number/digit ) &#123; case 1: System.out.print(\"yi\"); break; case 2: System.out.print(\"er\"); break; case 3: System.out.print(\"san\"); break; case 4: System.out.print(\"si\"); break; case 5: System.out.print(\"wu\"); break; case 6: System.out.print(\"liu\"); break; case 7: System.out.print(\"qi\"); break; case 8: System.out.print(\"ba\"); break; case 9: System.out.print(\"jiu\"); break; case 0: System.out.print(\"ling\"); break; &#125; number -= (number / digit) * digit; if (digit != 1) &#123; System.out.print(' '); &#125; &#125; &#125;&#125; 解决方案二： 123456789101112131415161718192021222324252627282930313233import java.util.*;public class hello&#123; public static void main(String[] args)&#123; Scanner s = new Scanner(System.in); int a = s.nextInt(); HashMap&lt;String,String&gt; pinyin = new HashMap&lt;String,String&gt;(); pinyin.put(\"0\",\"ling\"); pinyin.put(\"1\",\"yi\"); pinyin.put(\"2\",\"er\"); pinyin.put(\"3\",\"san\"); pinyin.put(\"4\",\"si\"); pinyin.put(\"5\",\"wu\"); pinyin.put(\"6\",\"liu\"); pinyin.put(\"7\",\"qi\"); pinyin.put(\"8\",\"ba\"); pinyin.put(\"9\",\"jiu\"); pinyin.put(\"-\",\"fu\"); String line = a+\"\"; String[] arr = line.split(\"\"); StringBuffer sb = new StringBuffer(); for(int i=0;i&lt;arr.length;i++)&#123; if(i==arr.length-1)&#123; sb.append(pinyin.get(arr[i])); &#125;else&#123; sb.append(pinyin.get(arr[i])+\" \"); &#125; &#125; System.out.print(sb.toString()); &#125;&#125; 解决方案三： 123456789101112131415161718192021222324252627282930import java.util.Scanner; public class Main&#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); String []str1 = &#123; \"ling\",\"yi\",\"er\",\"san\",\"si\",\"wu\",\"liu\",\"qi\",\"ba\",\"jiu\" &#125;; String str = in.next(); for(int i=0;i&lt;str.length();++i) &#123; if(i!=0)System.out.print(\" \"); String sub = str.substring(i,i+1); if(sub.equals(\"-\")) &#123; System.out.print(\"fu\"); &#125; for(int j=0;j&lt;10;++j) &#123; if(sub.equals(j+\"\")) &#123; System.out.print(str1[j]); break; &#125; &#125; &#125; in.close(); &#125;&#125; ​ 多项式加法（5分） 题目内容： 一个多项式可以表达为x的各次幂与系数乘积的和，比如： 2x6+3x5+12x3+6x+20 现在，你的程序要读入两个多项式，然后输出这两个多项式的和，也就是把对应的幂上的系数相加然后输出。 程序要处理的幂最大为100。 输入格式: 总共要输入两个多项式，每个多项式的输入格式如下： 每行输入两个数字，第一个表示幂次，第二个表示该幂次的系数，所有的系数都是整数。第一行一定是最高幂，最后一行一定是0次幂。 注意第一行和最后一行之间不一定按照幂次降低顺序排列；如果某个幂次的系数为0，就不出现在输入数据中了；0次幂的系数为0时还是会出现在输入数据中。 输出格式： 从最高幂开始依次降到0幂，如： 2x6+3x5+12x3-6x+20 注意其中的x是小写字母x，而且所有的符号之间都没有空格，如果某个幂的系数为0则不需要有那项。 输入样例： 6 2 5 3 3 12 1 6 0 20 6 2 5 3 2 12 1 6 0 20 输出样例： 4x6+6x5+12x3+12x2+12x+40 解决方案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Scanner;public class Main &#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); final int L = 101; int[] poly = new int[L]; int m=0, n=0; int count = 0; while(count&lt;2) &#123; m = in.nextInt(); n = in.nextInt(); if ( poly[m] != 0 ) &#123; poly[m] += n; &#125; else &#123; poly[m] = n; &#125; if ( m==0 ) &#123; count++; &#125; &#125; in.close(); // 判断最大幂 int maxM = 0; for ( int i = L; i &gt; 0; i-- ) &#123; if (poly[i-1] != 0 ) &#123; maxM = i-1; break; &#125; &#125; //分只有0次幂和有非0次幂两种情况 if (maxM == 0) &#123; //如果只有0次幂，直接输出 System.out.print(poly[0]); &#125; else &#123; for ( int i = maxM; i &gt; -1; i--) &#123; //非0次幂分幂大于1，幂等于1,每种情况中又分系数绝对值为1和不为1两种情况。 if ( i &gt; 1) &#123; if ( Math.abs(poly[i]) == 1 ) &#123; System.out.print(\"x\"+i); &#125; else if ( Math.abs(poly[i])&gt; 1 ) &#123; System.out.print(Math.abs(poly[i])+\"x\"+i); &#125; &#125; else if (i == 1 ) &#123; if ( Math.abs(poly[i]) == 1 ) &#123; System.out.print(\"x\"); &#125; else if ( Math.abs(poly[i]) &gt; 1) &#123; System.out.print(Math.abs(poly[i])+\"x\"); &#125; &#125; else &#123; if ( poly[i] != 0 ) &#123; System.out.print(Math.abs(poly[i])); &#125; &#125; if ( i &gt; 0)&#123; if ( poly[i-1] &gt; 0 ) &#123; System.out.print(\"+\"); &#125; else if(poly[i-1] &lt; 0) &#123; System.out.print(\"-\"); &#125; else &#123; System.out.print(\"\"); &#125; &#125; &#125; &#125; &#125; &#125; ​ 单词长度 题目内容： 你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出这行文本中每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it’s”算一个单词，长度为4。注意，行中可能出现连续的空格。 输入格式: 输入在一行中给出一行文本，以‘.’结束，结尾的句号不能计算在最后一个单词的长度内。 输出格式： 在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 输入样例： It’s great to see you here. 输出样例： 4 5 2 3 3 4 解决方案： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Hello &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String intString = in.nextLine(); in.close(); int n = 0, m = intString.length(); do &#123; n = intString.indexOf(\" \"); if (n == -1) &#123; if (intString.equals(\".\")) &#123; break; &#125; else &#123; System.out.print(intString.length()-1); &#125; &#125; else &#123; if (intString.equals(\".\")) &#123; break; &#125; else &#123; String strX = intString.substring(0, n); System.out.print(strX.length()); System.out.print(\" \"); &#125; &#125; for ( int i=n+1; i&lt;m; i++ ) &#123; if (intString.substring(i, i+1).equals(\" \")) &#123; continue; &#125; else &#123; intString = intString.substring(i); break; &#125; &#125; &#125; while(n&gt;0); &#125;&#125; GPS数据处理 题目内容： NMEA-0183协议是为了在不同的GPS（全球定位系统）导航设备中建立统一的BTCM（海事无线电技术委员会）标准，由美国国家海洋电子协会（NMEA-The National Marine Electronics Associa-tion）制定的一套通讯协议。GPS接收机根据NMEA-0183协议的标准规范，将位置、速度等信息通过串口传送到PC机、PDA等设备。 NMEA-0183协议是GPS接收机应当遵守的标准协议，也是目前GPS接收机上使用最广泛的协议，大多数常见的GPS接收机、GPS数据处理软件、导航软件都遵守或者至少兼容这个协议。 NMEA-0183协议定义的语句非常多，但是常用的或者说兼容性最广的语句只有$GPGGA、$GPGSA、$GPGSV、$GPRMC、$GPVTG、$GPGLL等。 其中$GPRMC语句的格式如下： $GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50 这里整条语句是一个文本行，行中以逗号“,”隔开各个字段，每个字段的大小（长度）不一，这里的示例只是一种可能，并不能认为字段的大小就如上述例句一样。 字段0：$GPRMC，语句ID，表明该语句为Recommended Minimum Specific GPS/TRANSIT Data（RMC）推荐最小定位信息 字段1：UTC时间，hhmmss.sss格式 字段2：状态，A=定位，V=未定位 字段3：纬度ddmm.mmmm，度分格式（前导位数不足则补0） 字段4：纬度N（北纬）或S（南纬） 字段5：经度dddmm.mmmm，度分格式（前导位数不足则补0） 字段6：经度E（东经）或W（西经） 字段7：速度，节，Knots 字段8：方位角，度 字段9：UTC日期，DDMMYY格式 字段10：磁偏角，（000 - 180）度（前导位数不足则补0） 字段11：磁偏角方向，E=东W=西 字段16：校验值 这里，“”为校验和识别符，其后面的两位数为校验和，代表了“$”和“”之间所有字符（不包括这两个字符）的异或值的十六进制值。上面这条例句的校验和是十六进制的50，也就是十进制的80。 提示：^运算符的作用是异或。将$和之间所有的字符做^运算(第一个字符和第二个字符异或，结果再和第三个字符异或，依此类推)之后的值对65536取余后的结果，应该和后面的两个十六进制数字的值相等，否则的话说明这条语句在传输中发生了错误。注意这个十六进制值中是会出现A-F的大写字母的。另外，如果你需要的话，可以用Integer.parseInt(s)从String变量s中得到其所表达的整数数字；而Integer.parseInt(s, 16)从String变量s中得到其所表达的十六进制数字 现在，你的程序要读入一系列GPS输出，其中包含$GPRMC，也包含其他语句。在数据的最后，有一行单独的 END 表示数据的结束。 你的程序要从中找出$GPRMC语句，计算校验和，找出其中校验正确，并且字段2表示已定位的语句，从中计算出时间，换算成北京时间。一次数据中会包含多条$GPRMC语句，以最后一条语句得到的北京时间作为结果输出。 你的程序一定会读到一条有效的$GPRMC语句。 输入格式: 多条GPS语句，每条均以回车换行结束。最后一行是END三个大写字母。 输出格式： 6位数时间，表达为： hh:mm:ss 其中，hh是两位数的小时，不足两位时前面补0；mm是两位数的分钟，不足两位时前面补0；ss是两位数的秒，不足两位时前面补0。 输入样例： 1$GPRMC,024813.640,A,3158.4608,N,11848.3737,E,10.05,324.27,150706,,,A*50 END 输出样例： 110:48:13 解决方案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.Scanner;public class hello &#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); String GPSOut; GPSOut = in.nextLine(); String lastGPMMC = null; boolean verify = true; while (!GPSOut.equals(\"END\")) &#123; lastGPMMC = GPSOut; int sum = 0; int GPSValue = 0; // 校验值 if (GPSOut.substring(0, 6).equals(\"$GPRMC\")) &#123; // ^运算 String GPString = GPSOut; char gString; int n = GPString.indexOf(\"*\"); for ( int i=1; i&lt;n; i++ ) &#123; gString = GPString.charAt(i); sum = sum^gString; &#125; GPSValue = Integer.parseInt(GPString.substring(n+1), 16); &#125; if (sum == GPSValue) &#123; verify = true; GPSOut = in.nextLine(); &#125; else &#123; verify = false; System.out.print(\"GPS输出 $GPRMC语句校验值错误！\"); break; &#125; &#125; in.close(); // 输出时间(UTC&gt;BJ) if (verify) &#123; String UTC = lastGPMMC.substring(7, 13); if(UTC.charAt(0)=='0') &#123; char sigle = UTC.charAt(1); String atime = String.valueOf(sigle); Integer btime = Integer.parseInt(atime); int stime=btime; int BJTstime = stime +8; if(BJTstime&lt;10) &#123; System.out.print(\"0\"+ BJTstime+ \":\"+lastGPMMC.substring(9, 11)+\":\"+lastGPMMC.substring(11, 13)); &#125; else &#123; System.out.print(BJTstime+ \":\"+lastGPMMC.substring(9, 11)+\":\"+lastGPMMC.substring(11, 13)); &#125; &#125; else &#123; String dou = UTC.substring(0, 2); Integer Ddou = Integer.parseInt(dou); int BJTdou=Ddou; if(BJTdou&lt;16) &#123; System.out.print(BJTdou+ \":\"+lastGPMMC.substring(9, 11)+\":\"+lastGPMMC.substring(11, 13)); &#125; else &#123; BJTdou = BJTdou + 8 - 24; System.out.print(\"0\"+ BJTdou+ \":\"+lastGPMMC.substring(9, 11)+\":\"+lastGPMMC.substring(11, 13)); &#125; &#125; &#125; &#125;&#125;// UTC &gt; 北京时间lastGPMMC = lastGPMMC.substring(lastGPMMC.indexOf(',')+1); lastGPMMC = lastGPMMC.substring(0,lastGPMMC.indexOf(','));lastGPMMC = lastGPMMC.substring(0,lastGPMMC.indexOf('.'));int time = Integer.parseInt(lastGPMMC);int hour;int minute;int second;if(time&lt;99999) &#123; time = time%100*10000+time/100%100*100+time/10000;&#125; else &#123; time = time%100*10000+time/100%100*100+time/10000;&#125; hour =time%100;if(hour&gt;=24) &#123; hour = hour - 16;&#125; else &#123; hour = hour + 8;&#125;minute = time/100%100;second = time/10000; if(hour&gt;9) &#123; System.out.print(hour+\":\"+minute+\":\"+second);&#125; else &#123; System.out.print(\"0\"+hour+\":\"+minute+\":\"+second);&#125; 分解质因数 题目内容： 每个非素数（合数）都可以写成几个素数（也可称为质数）相乘的形式，这几个素数就都叫做这个合数的质因数。比如，6可以被分解为2x3，而24可以被分解为2x2x2x3。 现在，你的程序要读入一个[2,100000]范围内的整数，然后输出它的质因数分解式；当读到的就是素数时，输出它本身。 输入格式: 一个整数，范围在[2,100000]内。 输出格式： 形如： n=axbxcxd 或 n=n 所有的符号之间都没有空格，x是小写字母x。 输入样例： 18 输出样例： 18=2x3x3 解决方案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.Scanner;public class Main &#123; public static boolean isPrime(int i) &#123; boolean isPrime = true; for ( int k=2; k&lt;i; k++ ) &#123; if ( i % k == 0 ) &#123; isPrime = false; break; &#125; &#125; return isPrime; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int inputNum = in.nextInt(); in.close(); boolean isP = isPrime(inputNum); int number = 0; if (!isP) &#123; System.out.print(inputNum+\"=\"); do &#123; for (int i=2; i&lt;inputNum; i++) &#123; if (inputNum%i==0) &#123; number = inputNum/i; inputNum = number; System.out.print(i); System.out.print(\"x\"); break; &#125; else &#123; continue; &#125; &#125; &#125; while(!isPrime(number)); System.out.print(number); &#125; else &#123; if (inputNum == 2) &#123; System.out.print(inputNum+\"=\"+inputNum); &#125; else &#123; System.out.print(inputNum); &#125; &#125; &#125;&#125; ​ 完数 题目内容： 一个正整数的因子是所有可以整除它的正整数。而一个数如果恰好等于除它本身外的因子之和，这个数就称为完数。例如6=1＋2＋3(6的因子是1,2,3)。 现在，你要写一个程序，读入两个正整数n和m（1&lt;=n&lt;m&lt;1000），输出[n,m]范围内所有的完数。 提示：可以写一个函数来判断某个数是否是完数。 输入格式: 两个正整数，以空格分隔。 输出格式： 其间所有的完数，以空格分隔，最后一个数字后面没有空格。如果没有，则输出一个空行。 输入样例： 1 10 输出样例： 6 解决方案： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package hello;import java.util.Scanner;public class Hello &#123; public static int[] IntegerDivisor(int m)&#123; int[] IntegerDivisor = new int[m]; int cut = 0; for ( int i=1; i&lt;m; i++ )&#123; if ( m % i == 0 )&#123; IntegerDivisor[cut] = i; cut ++; &#125; else &#123; continue; &#125; &#125; return IntegerDivisor; &#125; public static boolean isPerfectNumber(int arr[], int x)&#123; boolean isPerfectNumber = false; int sum = 0; for ( int i=0; i&lt;arr.length; i++ )&#123; sum += arr[i]; if (sum == x) &#123; isPerfectNumber = true; &#125; &#125; return isPerfectNumber; &#125; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); in.close(); int number = n; int cut = 0; int[] outputIntegerDivisor = new int[m]; do &#123; if (isPerfectNumber(IntegerDivisor(number), number)) &#123; outputIntegerDivisor[cut] = number; cut ++; &#125; number ++; &#125; while(number&lt;=m); for ( int j=0; j&lt;outputIntegerDivisor.length; j++ )&#123; if (outputIntegerDivisor[j] != 0) &#123; System.out.print(outputIntegerDivisor[j]); &#125; else &#123; System.out.println(); &#125; if (outputIntegerDivisor[j+1] != 0) &#123; System.out.print(\" \"); &#125; else &#123; break; &#125; &#125; &#125;&#125; ​","categories":[{"name":"Java","slug":"Java","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/"},{"name":"编程基础","slug":"Java/编程基础","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/编程基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://sophoraflower.github.io/EverQuest/tags/java/"}]},{"title":"Java基础知识汇总","slug":"Java基础知识汇总","date":"2017-12-19T23:41:00.000Z","updated":"2018-01-21T23:24:34.368Z","comments":true,"path":"2017/1220/Java基础知识汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/1220/Java基础知识汇总/","excerpt":"","text":"用程序来做计算 安装编程软件：Eclipse 第一个Java程序 123456package hello;public class Hello &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 输入 12345678910package hello;import java.util.Scanner;public class Hello &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"Hello\"); Scanner in = new Scanner(System.in); System.out.println(\"echo:\" + in.nextLine()); &#125;&#125; 变量 123456789101112package hello;import java.util.Scanner;public class Hello &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"Hello\"); Scanner in = new Scanner(System.in); int price; price = in.nextInt(); System.out.println(\"100-\" +price+\"=\"+ (100-price)); &#125;&#125; 定义变量、变量名、标识符、关键字（保留字）、变量类型 浮点数 1234// 档浮点数和整数方法哦一起运算时，Java会将整数转换成浮点数，然后进行浮点数运算System.out.println((x+y/2.0)*0.5);// 结果是0.30000000000000004 &gt; 浮点数System.out.println(3*0.1); 赋值 初始化、运算符、表达式、常量 12// 常量final int number =100; 优先级 一般自左向右；单目+-和赋值=自右向左 类型转换 123System.out.println((int)(x+y/2.0)*0.5);// 强制类型转换(浮点数取整去余数)x = （int）(30/3.0) 判断 比较 关系运算（关系运算符） 123456// 所有的关系运算符的优先级比算术运算低，但是比赋值运算的高// 判断是否相等的==和！=的优先级比其他的低，而连续的关系运算是从左到右进行的// 5 == 5.0 True// 5 === 5.0 False// 判断两个浮点数是否相等Math.abs(f1 - f2) &lt; 0.0001 做判断 12345// if语句if( total &gt; amount )&#123; total += amount+10;&#125;// DeBug模式、断点、step over等 判断语句 123456// 流程图if ( a&lt;b )&#123; max=b;&#125;else&#123; max=a;&#125; 嵌套和级联的判断 123456789101112131415161718192021// else总是和最近的那个if匹配// 在if或else后面总是用&#123;&#125;，即使只有一条语句的时候// 分段函数 &gt; if-else if-...-else// 单一出口，推荐int f; if ( x &lt; 0 ) &#123; f = -1;&#125; else if (x == 0) &#123; f = 0;&#125; else &#123; f = 2 * x;&#125;System.out.printIn(f)// 非单一出口if ( x &lt; 0 ) &#123; System.out.println(-1);&#125; else if (x == 0) &#123; System.out.println(0);&#125; else &#123; System.out.println(2 * x);&#125; 判断问题常见错误 123// 忘记大括号// if后加分号// 错误使用==和= 多路分支：switch-case 1234567891011121314// 控制表达式只能是整数型的结果// 常量可以是常数，也可以是常数计算的表达式// 根据表达式的结果，寻找匹配的case，并执行case后面的语句，一直到break为止switch （ 控制表达式 ） &#123; case 常量： 语句 ... case 常量： 语句 ... default: 语句 ...&#125; 循环 while循环 12345678910// while的条件是在进入循环体之前判断的，执行完一轮循环之后，会再回到循环开始的地方再次判断条件，而不会在循环体中随时判断条件// 条件成立循环继续的条件int number = in.nextInt();int count = 0;while( number &gt;0 )&#123; number = number / 10; count = count + 1;&#125;System.out.println(count); do…while循环 12345// 在进入循环体的时候不做检查，而是在执行完一轮循环体的代码之后，再来检查循环的条件是否满足，如果满足则进行下一轮循环，不满足则结束循环do&#123; &lt;循环体语句&gt;&#125;while(&lt;循环条件&gt;)； 计数循环 12// 循环执行次数// 循环结束（停止条件） 算平拘数 1// 变量-&gt;算法-&gt;流程图-&gt;程序 猜字游戏 整数分解 123456// 取整int num = 765;int intnum1 = num/100; // 7int intnum2 = (num - intnum1*100)/10 // 6// 取余int intnum3 = num%100 // 5 循环控制 for循环 1234567891011121314// for循环像一个计数循环：设定一个计数器，初始化它，然后在计数器到达某值之前，重复执行循环体，而每// 执行一轮循环，计数器值以一定步进进行调整for (int i=0;i&lt;5;i+1) &#123; System.out.pringln(i);&#125;// for ( 初始化; 条件; 步进调整 ) &#123;// // TODO//&#125;// for == whileint i=0;while( i&lt;5 )&#123; System.out.pringln(i);&#125;// 循环次数的确定 循环的选择 如果有固定的次数，用for 如果必须执行一次，用do_while 其他情况用while 符合赋值 循环控制 求解素数 12345678910111213int isPrime = 1;for ( int i=2; i&lt;=n; i++ ) &#123; if ( n%i == 0 ) &#123; isPrime = 0; System.out.println(\"不是素数\"); break; &#125; if ( isPrime==1 )&#123; System.out.println(\"是素数\"); &#125; else &#123; System.out.println(\"不是素数\"); &#125; &#125; break 与 continue break：跳出循环 continue：跳过循环这一轮剩下的语句进入下一轮 label: 在循环前防一个标号来标示循环，带标号的break和continue对那个循环起作用 多重循环（嵌套循环） 1// 100以内的素数 逻辑类型 12345boolean flag = true;// 逻辑运算x &gt; 4 &amp;&amp; x &lt; 6 // 4&lt;x&lt;6// 优先级!&gt;&amp;&amp;&gt;|| 循环例子 求和 最大公约数（辗转相除法） 数组 初识数组 1234int[] numbers = new int[100];// 定义数组变量int[] grades= new int[100];double[] averages= new double[20]; 数组的元素 123// 有效的下标// 长度array.length(); 数组变量 12345// 直接初始化数组int[] scores = &#123;11, 33, 55, 77, 90&#125;;// 数组变量赋值// 数组赋值、比较、管理权限// 数组复制 &gt; 遍历 遍历数组 1234567891011121314151617for ( int i=0; i&lt;data.length; i++ )&#123; if (x == data[i]) &#123; loc = i; break; &#125;&#125;// for-each循环，不可修改数组元素，可读取数组中的元素for ( int k : data )&#123; if ( k == x ) &#123; found = true; break; &#125;&#125; 素数求解的各种方法（思路） 二维数组 &gt; 多维数组 使用对象 字符类型 包裹类型 字符串 12345678910111213141516171819202122232425262728// 字符串变量String s = new String(\"a string\");// 字符串连接string1 + string2string + number// 比较两个字符串// 比较是否同一个if(input == \"bye\")&#123; ...&#125;// 比较内容是否相同if(input.equals(\"bye\"))&#123; ...&#125;// 字符串操作// 大小比较s1.compareTo(s2);// 字符串的长度str1.length();// 访问String里的字符,不能用for-each循环遍历字符串s.chartAt(index);// 切片s.substring(2, 4);// 查找字符位置s.indexOf(3)// 其他startsWith、endsWith、trim、replace、toLowerCase、toUpperCase// 所有的字符串操作都不能改变原字符串的值 函数 函数定义 12// 函数头（返回类型、函数名、参数表）// 函数体 函数调用 123// 传值// 形参，实参// 本地变量，局部变量，全局变量 ​","categories":[{"name":"Java","slug":"Java","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/"},{"name":"编程基础","slug":"Java/编程基础","permalink":"https://sophoraflower.github.io/EverQuest/categories/Java/编程基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://sophoraflower.github.io/EverQuest/tags/java/"}]},{"title":"EverQuest201712","slug":"EverQuest-2017-12","date":"2017-11-30T12:08:08.000Z","updated":"2018-02-02T17:20:46.383Z","comments":true,"path":"2017/1130/EverQuest-2017-12/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/1130/EverQuest-2017-12/","excerpt":"","text":"2017年11月30日 python代码500~1000行 《Python核心编程》- 正则表达式 Python3 + requests + cookies：模拟用户登录/登录接口测试/多用户模拟 职业规划（12月待考虑问题） 语言选择问题：C还是C++还是JAVA？ 日本IT市场（互联网、游戏、公司、开发环境、成长空间、对比国内） 深造的可能性（AI、大数据） 语言问题（N2、N1准备，托业准备） 什么时候去日本、待的时间、回国后怎么发展、婚姻、家庭、子女成长及教育 …… 2017年12月01日 需要登录接口测试用例模板 JMeter压力测试 + 自动化（Jenkins + Ant + JMeter） HTTP协议 CSDN学习日志每周汇总（争取每个月总结不少于10篇） 职业规划（12月待考虑问题） 语言选择问题：C还是C++还是JAVA？ 高级测试的发展前景 托业学习计划 淘宝、蚂蚁金服、阿里云、支付宝准备（明年七月~九月）：招聘要求、技能 工作日及周日时间安排 ​ 2017年12月02日 熟悉使用JMeter等性能测试工具，有二次开发经验优先； 熟悉使用Linux系统； 熟悉Nginx、Redis等应用服务器配置与管理； 熟悉掌握MySQL、mongodb等常用数据库系统的操作，能熟练编写复杂SQL语句； 大型网站性能测试经验； 深入了解HTTP、TCP/IP等网络协议，熟悉J2EE Web系统，熟悉掌握多种中间件（Tomcat、Apache、Nginx、MQ等）各项性能参数设置、监控及优化； Web安全、安全测试、渗透测试 shell、javascript、Python 脚本语言 Java语言 计算机基础（长久性学习） ​ 2017年12月03日 Java（核心） &gt; Web方向 计算机基础（计算机网络、操作系统、计算机组成原理、算法、数据库） Python开发（自动化测试、爬虫、数据分析、Web） 数据可视化、性能测试 Language：English &gt; TOEIC","categories":[{"name":"EverQuest","slug":"EverQuest","permalink":"https://sophoraflower.github.io/EverQuest/categories/EverQuest/"}],"tags":[]},{"title":"Unittest单元测试框架","slug":"Unittest单元测试框架","date":"2017-09-09T15:35:00.000Z","updated":"2018-01-21T23:49:39.408Z","comments":true,"path":"2017/0909/Unittest单元测试框架/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/0909/Unittest单元测试框架/","excerpt":"","text":"单元测试框架功能&emsp;&emsp;提供用例编写规范与批量执行，提供丰富的断言方法，例如断言相等/不相等、包含/不包含，True/Flase等，提供丰富的测试日志（失败信息、成功用例数、执行时间）。 常见自动化测试框架+工具： HTTP接口自动化测试：unittest + Requests Web UI自动化测试：unittest（TestNG） + Selenium 移动自动化测试：unittest + Appium 测试用例编写1234567891011121314151617181920212223242526272829303132class GamesInfo(unittest.TestCase): \"\"\"获取游戏列表\"\"\" # https://apis.zhanqi.tv/static/v2.2/tv/games.jsondef setUp(self): self.url = 'https://apis.zhanqi.tv/static/v2.2/tv/games.json' mylog.info(\"接口:获取游戏列表，测试开始\")def tearDown(self): mylog.info(\"接口:获取游戏列表，测试完成\")def test_gamesInfo_success(self): \"\"\"获取成功\"\"\" r = requests.get(self.url) self.response_data = r.json() self.assertEqual(self.response_data['code'], 0, msg='ERROR:获取失败') self.assertEqual(self.response_data['message'], 'OK', msg='ERROR:返回值错误') print(self.response_data)def test_roomInfo_games(self): \"\"\"直播间列表\"\"\" r = requests.get(self.url) self.response_data = r.json() self.assertTrue(isinstance(self.response_data['data'], list), msg=\"ERROR:返回数据类型错误\") print(self.response_data['data'])# 直播间列表 - game结构def test_roomInfo_img(self): \"\"\"游戏图\"\"\" r = requests.get(self.url) self.response_data = r.json() self.assertTrue(self.response_data['data'][0]['img'], msg=\"ERROR:游戏图为空\") print(self.response_data['data'][0]) &emsp;&emsp;首先，通过import导入unittest测试框架。创建GamesInfo类继承unittest.TestCase类。setUp()和tearDown()两个方法分别在每一个测试用例的开始和结束时执行。setUp()用于测试用例执行前的初始化工作，例如初始化变量、生成数据库测试数据、打开浏览器等。tearDown()方法用于测试用例执行之后的善后工作，例如清除数据库测试数据、关闭文件、关闭浏览器等。&emsp;&emsp;unittest要求测试用例（方法）必须以“test”开头。例如test_gamesInfo_success、test_roomInfo_games等。 执行测试用例 方案一：unittest.main()方法会搜索该模块下所有以test开头的测试用例方法，并自动执行它们。执行顺序是命名顺序：先执行test_case1，再执行test_case2 1unittest.main() 方案二： 先构造测试集 1suite=unittest.TestSuite() # 实例化测试套件将测试用例加载到测试套件中。 执行顺序是安装加载顺序：先执行test_case2，再执行test_case1 12suite.addTest(Test('test_case2'))suite.addTest(Test('test_case1')) 执行测试用例 12runner=unittest.TextTestRunner() # 实例化TextTestRunner类runner.run(suite) # 使用run()方法运行测试套件（即运行测试套件中的所有用例） 方案三： 构造测试集（简化了方案二中先要创建测试套件然后再依次加载测试用例），执行顺序同方案一：执行顺序是命名顺序：先执行test_case1，再执行test_case2 12test_dir = './'discover= unittest.defaultTestLoader.discover(test_dir, pattern='test_*.py') 执行测试用例 12runner=unittest.TextTestRunner() # 实例化TextTestRunner类runner.run(discover) #使用run()方法运行测试套件（即运行测试套件中的所有用例） 常用断言方法(assert*)123456789101112assertEqual(a, b, msg='测试失败时打印的信息') # 断言a和b是否相等，相等则测试用例通过assertNotEqual(a, b, msg='测试失败时打印的信息') # 断言a和b是否相等，不相等则测试用例通过assertTrue(x, msg='测试失败时打印的信息') # 断言x是否True，是True则测试用例通过assertFalse(x, msg='测试失败时打印的信息') # 断言x是否False，是False则测试用例通过assertIs(a, b, msg='测试失败时打印的信息') # 断言a是否是b，是则测试用例通过assertNotIs(a, b, msg='测试失败时打印的信息') # 断言a是否是b，不是则测试用例通过assertIsNone(x, msg='测试失败时打印的信息') # 断言x是否None，是None则测试用例通过assertIsNotNone(x, msg='测试失败时打印的信息') # 断言x是否None，不是None则测试用例通过assertIn(a, b, msg='测试失败时打印的信息') # 断言a是否在b中，在b中则测试用例通过assertNotIn(a, b, msg='测试失败时打印的信息') # 断言a是否在b中，不在b中则测试用例通过assertIsInstance(a, b, msg='测试失败时打印的信息') # 断言a是是b的一个实例，是则测试用例通过assertNotIsInstance(a, b, msg='测试失败时打印的信息') # 断言a是是b的一个实例，不是则测试用例通过 推荐文档：Unittest单元测试框架总结","categories":[{"name":"Python","slug":"Python","permalink":"https://sophoraflower.github.io/EverQuest/categories/Python/"},{"name":"自动化测试","slug":"Python/自动化测试","permalink":"https://sophoraflower.github.io/EverQuest/categories/Python/自动化测试/"}],"tags":[{"name":"python","slug":"python","permalink":"https://sophoraflower.github.io/EverQuest/tags/python/"}]},{"title":"D3.js小结","slug":"D3.js 小结","date":"2017-05-28T13:13:00.000Z","updated":"2018-01-20T23:48:45.658Z","comments":true,"path":"2017/0528/D3.js 小结/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/0528/D3.js 小结/","excerpt":"","text":"D3：数据可视化库(D3 4.0+)&emsp;&emsp;D3是目前最流行的JavaScript可视化图表库之一，D3的图表类型非常丰富，并且支持SVG格式，因此应用十分广泛，也有很多图表插件基于D3开发，比如MetricsGraphics.js，在D3上构建的数据图表非常强大。1234567// 引用D3对象// select()方法返回一个对DOM中匹配的第一个元素的引用d3.select(\"body\") // append()会创建一个新的DOM元素,然后把它追加到调用它的元素末尾 .append(\"p\") // text()接受一个字符串，把它插入到当前元素的开始和结束标签之间 .text(\"New paragraph!\") 123456789d3.select(\"body\") // 选择DOM中的所以段落。没有段落时，返回空元素 .selectAll(\"p\") // 解析并输出数据值 .data(dataset) // 创建新的绑定数据的元素（占位元素） .enter() .append(\"p\") .text(\"New paragraph\"); 数据加载CSV数据1234567891011d3.csv(&quot;xxx.csv&quot;, function(error, data)&#123; if (error) &#123; console.log(error); &#125; else &#123; // 把CSV数据交给全局变量 dataset = data; // 调用生成可视化图标的其他函数 generateVis(); hideLoadingMsg(); &#125;&#125;) 加载JSON数据1234d3.json(&quot;waterfallvelocities.json&quot;, function(json)&#123; console.log(json); // todo json data&#125;) SVG12345678910111213141516171819202122232425262728// 创建SVG元素var w = 500, h = 70;var svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h);var dataset = [5, 10, 15, 20, 25];// 创建圆形var circles = svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\");// i为从0开始的整数，d为dataset[i]circles.attr(\"cx\", function(d, i)&#123; return (i * 50) + 25; &#125;) .attr(\"cy\", h/2) .attr(\"r\", function(d)&#123; return d; &#125;) // 填充 .attr(\"fill\", \"yellow\") // 描边 .attr(\"stroke\", \"orange\") .attr(\"stroke-width\", function(d)&#123; return d/2; &#125;); &emsp;&emsp;&emsp;&emsp; 条形图1234567891011121314151617181920212223242526272829&lt;script&gt; var w = 500, h = 100, barpadding = 1; var dataset = [ 15, 20, 13, 15, 17, 19, 60, 55, 34, 19, 57, 99, 55, 61, 77, 64, 81, 56, 33, 24 ]; var svg = d3.select(\"body\").append(\"svg\").attr(\"width\", w).attr(\"height\", h); // 创建矩形 svg.selectAll(\"rect\").data(dataset).enter().append(\"rect\") .attr(\"x\", function(d, i)&#123; return i * (w / dataset.length); &#125;).attr(\"y\", function(d)&#123; return h - d; &#125;).attr(\"width\", w / dataset.length - barpadding).attr(\"height\", 100) .attr(\"fill\", function(d)&#123; return \"rgb(0, 0, \" + (d * 10) + \")\"; &#125;); // 值标签 svg.selectAll(\"text\").data(dataset).enter().append(\"text\") .text(function(d)&#123; return d; &#125;) .attr(\"x\", function(d, i)&#123; return i * (w / dataset.length) + 11; &#125;) .attr(\"y\", function(d)&#123; return (h-d) + (h-(h-d))/2 + 2; &#125;) .attr(\"font-family\", \"sans-serif\") .attr(\"font-size\", \"11px\") .attr(\"fill\", \"white\") // 水平居中文本 .attr(\"text-anchor\", \"middle\");&lt;/script&gt; 比例尺和数轴创建通用的数轴函数原写法： 123var xAxis = d3.svg.axis();xAxis.scale(xScale);xAxis.orient(bottom); 最新写法 123var xAxis = d3.axisBottom().scale(xScale);var yAxis = d3.axisLeft() .scale(yScale); 创建线性比例尺原写法： 1var xScale = d3.scale.linear().domain([0, 100]).range(0, 10); 最新写法： 1var xScale = d3.scaleLinear().domain([0, 100]).range(0, 10); 散点图示例1234567891011.axis path,.axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges;&#125;.axis text &#123; font-family: sans-serif; font-size: 11px;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 //Width and height var w = 500; var h = 300; var padding = 30; //Dynamic, random dataset var dataset = []; //Initialize empty array var numDataPoints = 50; //Number of dummy data points to create var xRange = Math.random() * 1000; //Max range of new x values var yRange = Math.random() * 1000; //Max range of new y values for (var i = 0; i &lt; numDataPoints; i++) &#123; //Loop numDataPoints times var newNumber1 = Math.floor(Math.random() * xRange); var newNumber2 = Math.floor(Math.random() * yRange); dataset.push([newNumber1,newNumber2]); &#125; //Create scale functions var xScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[0]; &#125;)]) .range([padding, w - padding * 2]); var yScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[1]; &#125;)]) .range([h - padding, padding]); var rScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[1]; &#125;)]) .range([2, 5]); //Define X axis var xAxis = d3.axisBottom() .scale(xScale) .ticks(5); //Define Y axis var yAxis = d3.axisLeft() .scale(yScale) .ticks(5); //Create SVG element var svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); //Create circles svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") .attr(\"cx\", function(d) &#123; return xScale(d[0]); &#125;) .attr(\"cy\", function(d) &#123; return yScale(d[1]); &#125;) .attr(\"r\", function(d) &#123; return rScale(d[1]); &#125;); //Create labels svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text(function(d) &#123; return d[0] + \",\" + d[1]; &#125;) .attr(\"x\", function(d) &#123; return xScale(d[0]); &#125;) .attr(\"y\", function(d) &#123; return yScale(d[1]); &#125;) .attr(\"font-family\", \"sans-serif\") .attr(\"font-size\", \"11px\") .attr(\"fill\", \"red\"); //Create X axis svg.append(\"g\") .attr(\"class\", \"axis\") .attr(\"transform\", \"translate(0,\" + (h - padding) + \")\") .call(xAxis); //Create Y axis svg.append(\"g\") .attr(\"class\", \"axis\") .attr(\"transform\", \"translate(\" + padding + \",0)\") .call(yAxis); 更新，过渡和动画交互式图表布局地图","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"数据可视化","slug":"Web前端/数据可视化","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/数据可视化/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"软件测试管理","slug":"软件测试管理","date":"2017-04-24T15:35:00.000Z","updated":"2018-01-20T23:46:46.485Z","comments":true,"path":"2017/0424/软件测试管理/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/0424/软件测试管理/","excerpt":"","text":"文章依据《我是怎样做测试管理的？》，《测试管理的一点心得体会》，对测试管理过程做了简单的描述和总结。 情景再现有方法与无方法&emsp;公司现状：创业公司，误打误撞进了软件这一行当，但软件这行是否可以持续走，是否要持续走，BOSS还不确定，如果卖的不好就不做软件了，改做别的。现在是生存阶段，有项目就接上。上面有BOSS关系搞定，下面有老实的干活人努力加班，项目也就过得去。 &emsp;软件测试：公司发动了所有实施顾问来测试，只有他们通过，才能去实施。实施顾问大多来自刚刚毕业的应届毕业生，对企业管理，对软件，对行业领域，都一无所知。对测试更是一窍不通。测试并没有分工，每个人都测试软件。也没有什么测试方法，也没有什么测试计划，也不知道该测什么。反正也是对软件不了解，就当是深入学习软件。 &emsp;遇到问题：开始并没有测试报告，大家发现问题，就用电话或QQ或邮件，把问题发给开发人员。谁认识那个开发人员，就发给那个开发人员，如果不认识一个开发人员，就发给老板了。报告中尽是不好用，不能用的词汇。但什么功能不好用，是怎么操作导致不好用，不好用的具体表现是什么，都没有。老板急眼了，怎么这么多问题。 &emsp;原因分析： 很多问题都是每个人都反映了，其实只有一个问题，只不过大家没有分工，都测试，于是都报告； 不少人见一个问题发一个邮件，所以看起来很多； 有的人测试只是随便乱点乱输入，咱们软件还没有做这种破坏性操作兼容防范； 不少人不了解功能，不了解行业，不了解业务，本来是对的，按他的理解是错的； 有些人偷懒，今天发的是这些问题反馈，后天又是同样。 &emsp;解决措施： 分工测，几个人测试一块功能； 不全部测，只测试那些很常用的重点功能； 不要电话、QQ、邮件来报告给单独的开发人员，给我一个人发就可以了，我来判断衡量安排。也不要随时报告。每天下班的时候来统一发送，由各个测试小组的负责人来汇总自己组内的测试，并且把重复的问题合并掉； 每个测试小组的每天的测试报告要连续在一起，不要今天发今天的测试EXCEL，明天是明天的测试EXCEL，这样没有连贯性； 每个问题，要标好功能模块，有测试人，有测试版本号，有测试时间，有测试操作过程，有测试输入数据，有报错截图； 先测试正常的数据输入，正常的操作流程，是否能全部流程走通，是否数据保存正常，是否保存后的数据还能正确的取出来。那些临界条件测试先不要做。对于功能不易操作、界面不好看、起的窗口标题是否得当，字体是否加粗这些需求不要提。咱们目前阶段的重点是测试问题，不要把需求和找问题混在一起。 巧妇难为无米之炊&emsp;公司现状：第一批客户的实施终于启动了，实施顾问奔向了全国。随着项目的实施，公司渐渐拢回来不少钱，但是面临了一个瓶颈，这个大项目快做完了，以后有什么活能养活现在这么多人呢。所以，最好的做法就是把现在这个项目产生的软件改改，变成一个产品，卖给其他的客户，卖的越多越好。但是，其他客户我们有关系的并不多，所以要想销售给其他客户，必须拿产品说话。于是，研发部陆续加入了专职的测试人员、文案人员、美工人员，旨在提高产品的质量和包装，希望能卖个好价格。所以说，专职的测试人员是这么来的。 &emsp;软件测试：很多软件公司没有测试人员，其原因就是老板搞定关系，程序员老实干活，项目质量虽然不行，但也能将就把钱结了。既然能赚钱，干嘛要测试人员呢。除非由于质量问题，签不到单子。除非由于质量问题，客户不验收不给尾款。除非公司所有人都测试还是无法达到客户满意的质量。只有这样，才会招聘专职的专业的测试人员。测试人员一来了，开始工作。但怎么开展测试呢？文档在哪里？ &emsp;遇到问题： 对测试，对软件，对业务的理解肤浅。过去发现的问题都是小儿科，真正复杂的问题根本没有测试到。给客户一讲解，客户一问，发现原来很多功能细节没有理解，不知道怎么给客户解释； 文档只有很老的设计文档，现在软件和文档已经毫无关系； 测试人员硬着头皮，开始学习软件，什么是正确的什么是不正确的，测试人员也不知道，当然也不知道BUG究竟是什么样。软件质量仍然没有改进。 帮助在哪里？没有？因为没有写帮助文件的人。只有打单的时候讲解的PPT； 改进初期，测试来测试去，其测试结果和实施人员的测试没多大区别，都还是在门外转。 老板问：这个测试人员是不是没啥能力？要不要裁掉？ &emsp;原因分析： 实施顾问对软件本身的理解思路和自身的理解层次，其次是用户（客户）理解能力的高低及要求； 都是程序员，谁来专门写文档。为了公司生存，我身兼数职，到处开会做项目经理或做售前，还管开发人员，还有实施人员给我打电话问软件中某个功能怎么回事，我也分身无术；都是根据实施人员、客户、销售人员、老板反映的需求和BUG修改。那些BUG和需求EXCEL表格倒是有，但没法作为测试案例编写的根据。 没有写帮助文件的人。只有打单的时候讲解的PPT。 由于几年发展，软件加入了大量客户的需求，很多细节的东西在帮助中也没有看到，测试人员也不知道有这个功能。 &emsp;解决措施： 一方面仍然要求他们按照过去的测试问题报告流程和方法来报告实施现场中发现的问题，另一方面我自己写了FAQ给实施顾问发出去。但是实施顾问仍然问，一个问题重复的问。我说你看FAQ的第XX行。他说他看了，但没看明白（其实是对客户业务不了解，所以也不明白功能）。我就给他再解释。经过多次解释，我也了解了实施顾问的理解思路和理解层次，于是不断修正FAQ，使FAQ1.0、FAQ1.1.1这样不断发布，几乎天天发布。我现在回过头来想，帮助文件写的好不好，不能你说你自己已经写的很明白了傻瓜才看不懂，不要这样认为，这样根本不解决问题。唯一的方法就是用户理解能力有多低，你就要把帮助写的有多低，让他理解是目的，要不你还能怎样呢，就这样的人，问题还得解决。 文案人员也不了解软件，她写出来的也是自己猜测，所以我已经分出来一个开发人员做项目经理，他目前专门负责把帮助文档建立起来，但是他开发人员出身不擅长写文档，但他熟知软件，所以只有他们两个人搭配才能搞定。但这种磨合，需要时间。 测试人员硬着头皮，一边测试人员瞎学习瞎测试，一边项目经理和文案人员不断讲解不断编写不断审核不断修改。 巧妇难为无米之炊。果不其然，测试人员有其独到的软件测试方法、软件理解方法。很快，测试人员对软件的理解不亚于那些多年的实施顾问，也不亚于程序员。找问题也越来越准确，越来越深入。当然，其原因也在于这个团队的成长，有专职的项目经理开始书写现有功能需求修改的设计文档。过去的，没有的，就让它过去，就让它缺失吧，但未来，不要成为过去。现在也有专职的文案，不断在修改帮助，加深了许多。测试人员现在比文案人员理解功能更细，更深入，经常提醒文案人员应该把某句话写进帮助中，否则容易被用户忽略，是个不小心就会绊倒的坑。 各司其职。对症下药&emsp;遇到问题：在过去，服务部小姑娘老把电话转给开发人员，本来就几条枪，被客户电话吵的无法安心开发。而且客户发现开发人员接听电话处理问题更有效，所以很多客户都是直接给开发人员打电话，服务部成了虚架子，而开发人员的开发进度被拖累，叫苦不迭。 &emsp;解决措施：为了使测试人员更快速的了解客户应用操作方法，更细节的了解特个性的功能，我让测试人员也兼任研发部的技术支持。现在有了测试人员兼任技术支持，这下解放了开发人员。开发的质量和速度提高许多。 &emsp;引发问题：测试人员并没有做技术支持的经验，过了段时间就来和我诉苦，说现在服务部小姑娘啥也不干，都直接把电话转到他这里来，所以他现在已经无法测试了，成了专职的服务支持人员。如果再这样下去，软件质量无法保证，以后的技术支持压力更重，开发部就会成为开发+服务部门。 &emsp;解决措施（针对测试）： 经常遇到的问题，就做成FAQ。下一次还有小姑娘问，直接让她看FAQ，拒不回答。 交给他们方法和思路，不替他们亲自做。亲自看着她，让她服务支持客户。一次不会，再继续这样做第二次，必须让她自己亲自会了。 每个星期六定期培训，疑问解答。并且考试。如有讲过后考试还不会者，扣钱。 &emsp;解决措施（针对服务部门）：你接待了多少客户问题，解决时间多长，多少个问题转给开发部技术支持了，这些问题的难度级别多高。根据这些指标来衡量服务部小姑娘们的技术解决问题能力。能力差的就辞退。 统一战线，旗帜分明&emsp;遇到问题：于有时候客户报告了某个BUG，程序员一看好改就直接改掉了，改完后就直接联系客户更新了，但是并没有更改软件版本号，也没有做新的打包。于是出现了同一个版本号软件功能表现却不同。而且，由于项目组多了，每个项目组组长都各有各的原因，有时候自己就打了一个包给了客户，随便定个版本号，起的都稀奇古怪，有的叫beta版，有的叫6.0.20050203。这种情形导致了测试人员做测试的时候，开发人员说改了，测试人员说没改。开发人员说已经没有问题了，测试人员说我这里还能重复出来。于是两个人一起查，耗费了两天时间，才查出来测试人员手里的和开发人员手里的不一致。 &emsp;解决措施： 开发人员绝对不能接触客户，不能接听客户电话，也不能解决客户问题，更不能给客户更新； 开发人员不能没有任务分配和设计文档就擅自修改软件，否则记过处分； 大家一致使用版本管理工具、BUG管理工具、需求管理工具、任务管理工具。用工具把项目经理、开发人员、测试人员、文案人员绑定在一起，按固化流程推进流转； 打包发布统一交给测试人员来做，测试人员来控制是否可以发布，发布的版本号的命名。质量达不到，有权不能发布。 有的放矢，步步为营&emsp;&emsp;我们的测试已经能做边界测试、版本兼容性测试、系统兼容性测试、压力测试、安全测试、集成测试、破坏性测试。也已经在项目中应用全程测试，测试人员主要参与需求验证、设计验证、代码验证、文档验证、打包验证。 &emsp;&emsp;但是，我们现在还没有实现单元测试，开发人员就这些人，项目却多。而且测试人员没有编程能力。我们也没有做更多的回归测试，毕竟测试人员数量配备太少，而项目并行太多。 &emsp;&emsp;看机会吧。老板越从软件上赚钱，他才会越舍得投入软件。成本永远嫌多，利润永远嫌少。 &emsp;&emsp;如果你是一名开发主管，你的老板还没有从你负责的软件中赚钱，而且是很快乐的很大规模的赚钱，而不是他靠他的人际关系和送礼吃饭支撑着，我想，他不会给你一毛钱的。你抱怨也没有用，因为你没有价值，所以投入也是没有意义。 &emsp;&emsp;先去证明你的价值吧。 测试管理总结 1、组间合作 与开发、实施等组间良好的沟通与配合是非常重要的。这需要大家对目标认识的一致性及相互的理解与包容。实施人员直接面对的是用户，他们提出的任务不多，但都是比较重要的，需要直接交付于用户的。往往也是比较紧急的，所以沟通时必须确认好交付时间，以最高优先级来处理并以高质量来完成。 测试负责人不仅仅是关注测试那部分的工作，也需要关注整个项目的动态。实时了解项目的进度，了解每个阶段用户使用相对较多的模块，以了解本阶段的主要工作，把握本工作的重点，也能提前作好准备工作。同时发现项目在哪方面存在问题时，也可以用巧妙的方式来提醒，让他知道你是好意而不是对他工作的否定。如果经常能帮助到他们，我想对方也会欣然接受。 2、测试负责人的工作职责 沟通协调工作也必须做好，当多个任务同时提交时，一定要问清楚紧急程度，系统是否要急于发布，文档是否急于交付。不急于发布的也可以让先发布好环境，因为往往发布系统都需要一定的时间，在其它系统没发布好前可以先进行测试。每项任务都需要了解范围，预计需要投入的工作及计划安排的人员。同时要做好突发性任务的准备。 测试负责人要有计划性和预见性，根据之前项目的经验判断出在某个阶段会有哪些工作要做，在任务不是很繁忙的时候要提前去做，这个是非常重要的。像文档能准备的尽早准备，交付前稍做检查更新就好了。在上线前一般系统会非常忙，根本没时间去修改文档等其它工作。 重要的任务需要亲自把关，或安排信得过的人去检查。对于客户交付的文档对于内容和格式都务必要正确。像用户手册等是用户需要使用的，所以内容的正确性与现有系统的一致性就比较重要。对于测试用例、缺陷记录、出厂测试报告等文档的内容用户不是太关心的，格式则比内容更重要。对于发布前的那次测试一定要进行整体测试。不要相信因开发说哪些地方没改不会存在问题的说法，对于修改的模块或功能，与之相关的功能进行重点测试，未涉及到修改的模块也要把每个功能简单测试一下。开发修改缺陷时经常会把关联的地方没关注到，还有经常作了一些小的改动没有提交测试，时间久了就忘了哪些地方作了修改了。 把合适的人放在合适的位置。团队的每一位成员特长不可能都会一样，每个方面不可能同样的优秀。有些可能是技术方面强一些，有些在业务方面要强一些，有的可能在管理方面要强一些；有的性格开朗善于沟通，有的不善言辞但敏于思考，能耐得住寂寞。前者可以多做些沟通及工作协调的事，后者可以多安排些技术研究或检查文档等需要细心一点的工作。当然也要让组员明白，不是自己想要做什么就能做什么，一切必须以当前的任务情况来做安排，在条件许可的情况下会优先考虑。自己可以利用业余的时间去学习，充实自己，一旦机会来临才能去胜任。 要善于观察组内成员的工作状态，及时发现哪些人状态不好，及时沟通及协助解决。 要定期向上级领导汇报工作情况，让领导了解组内的工作情况，同时当需要申请资源时也会容易些。同时也需要让组员了解一下自己的工作情况，他们可能只了解你参与测试的这部分工作，其它工作并不了解。不要让组员认为什么事都让下面人做，自己却没做多少事。 3、组内管理 一个好的团队必须有良好的团队氛围，必须要有共同的目标，这点很重要。如果经常意见不一致在喋喋不休地争论，这样什么事情都不可能做好。当然这并不代表大家不能发表自己的意见。讨论问题时大家都是平等的，要尽情开放的地讨论，把大家的建议都发表出来，最后采取的方案也要取得大多数人的认同，但一旦确定一个执行方案后大家都要按照来执行。 要合理安排资源，以免部分人员工作强度很高，部分人员又会有空闲时间。这样也会引起忙的人心里不平衡。这个是有点难度，但需要尽可能地安排好。每个项目的测试人员要多考虑一两个备份人员，具体人数视项目情况。每个阶段每个项目的工作量都不一样，安排时根据每个项目进度情况来合理备配人员，尽量做到大家的工作量不会出现太大的差异。当任务少时，可以多安排一些研究性的工作为一个阶段的工作做准备，多安排业务交流，文档走查的工作等，也可以对前段时间的工作总结。像年初年末，工作状态可能也不会很好，此时就可以做一下总结，计划一下来年的工作。 每个小组的测试项目越来越多，可以采用分级管理模式，每个项目设立一位负责人，既提高了大家的责任感，提高了自己的管理能力。同时也让大家从工作中学会了换位思考，体会到做组员和负责人的立场与想法，也分担了组长的工作。","categories":[{"name":"调优","slug":"调优","permalink":"https://sophoraflower.github.io/EverQuest/categories/调优/"},{"name":"软件测试","slug":"调优/软件测试","permalink":"https://sophoraflower.github.io/EverQuest/categories/调优/软件测试/"}],"tags":[{"name":"测试管理","slug":"测试管理","permalink":"https://sophoraflower.github.io/EverQuest/tags/测试管理/"}]},{"title":"上海-西塘-绍兴","slug":"上海-西塘-绍兴","date":"2016-08-07T16:00:00.000Z","updated":"2018-01-20T23:49:26.239Z","comments":true,"path":"2016/0808/上海-西塘-绍兴/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0808/上海-西塘-绍兴/","excerpt":"","text":"上海(^)西塘 绍兴","categories":[{"name":"LifeStyle","slug":"LifeStyle","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/"},{"name":"摄影","slug":"LifeStyle/摄影","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/摄影/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://sophoraflower.github.io/EverQuest/tags/摄影/"}]},{"title":"《页面架构》课堂交流问题汇总","slug":"《页面架构》课堂交流问题汇总","date":"2016-06-28T10:21:00.000Z","updated":"2018-01-21T23:16:38.967Z","comments":true,"path":"2016/0628/《页面架构》课堂交流问题汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0628/《页面架构》课堂交流问题汇总/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《页面架构》学习总结 居中布局问题一：水平列表的底部对齐如图所示，一个水平排列的列表，每项高度都未知，但要求底部对齐，有哪些方法可以解决呢？ &emsp;&emsp;&emsp;&emsp; 解决方案： 方法一：子元素设置：display：inline-block + vertical-align:bottom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; &#125; .child&#123; display:inline-block; vertical-align:bottom; &#125; .child_a&#123; width:150px; height:100%; background:red; &#125; .child_b&#123; width:150px; height:75%; background:green; &#125; .child_c&#123; width:150px; height:50%; background:black; &#125; .child_d&#123; width:150px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法二：position:relative + 子元素：position:absolute + bottom：0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; position:relative; &#125; .child&#123; position:absolute; bottom:0; &#125; .child_a&#123; width:150px; height:100%; left:15px; background:red; &#125; .child_b&#123; width:150px; left:180px; height:75%; background:green; &#125; .child_c&#123; width:150px; left:345px; height:50%; background:black; &#125; .child_d&#123; width:150px; left:510px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法三：父元素：dispaly:flex + align-items:flex-end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; display:flex; align-items:flex-end; &#125; .child&#123; margin-left:15px; &#125; .child_a&#123; width:150px; height:100%; background:red; &#125; .child_b&#123; width:150px; height:75%; background:green; &#125; .child_c&#123; width:150px; height:50%; background:black; &#125; .child_d&#123; width:150px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法四：弹性盒模型 &emsp;&emsp;相关重点文章推荐： &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（一） &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（二） &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（三）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; display:box; // 设置为盒子显示 display:-moz-box; display:-webkit-box; orient:horizontal; // 定义父元素内子元素的流动 -mozbox-orient:horizontal; -webkit-orient:horizontal; box-align:end; -moz-box-align:end; -webkit-box-align:end; &#125; .child&#123; &#125; .child_a&#123; width:200px; height:500px; background:red; &#125; .child_b&#123; background:green; width:200px; height:350px; &#125; .child_c&#123; background:black; height:250px; width:200px; &#125; .child_d&#123; width:200px; height:150px; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 问题二：实现一个幻灯布局&emsp;&emsp;一个幻灯片效果如图： &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;已知结构如下： 12345&lt;div class=\"slide\"&gt; &lt;!-- 图片省略 --&gt; &lt;!-- 以下是指示器 --&gt; &lt;div class=\"pointer\"&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;要求如下：幻灯（slide）宽高未知，指示器（pointer）在底部且水平居中，距离底部10px，指示器中的圆直径为10px，个数未知，背景为黑色，间距为5px，请完成CSS。 &emsp;&emsp;解答：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;幻灯图&lt;/title&gt; &lt;style type=\"text/css\"&gt; .slide&#123; width:600px; height:300px; background:#9dc3e6; position:relative; &#125; .pointer&#123; position:absolute; left:50%; transform:translate(-50%); bottom:10px; &#125; .pointer i&#123; display:block; float:left; margin-right:5px; width:10px; height:10px; border-radius:50%; background-color:black; &#125; .pointer i:last-child&#123; margin-right:0; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"slide\"&gt; &lt;!-- 图片省略 --&gt; &lt;!-- 以下是指示器 --&gt; &lt;div class=\"pointer\"&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多列布局问题一：一个全等四宫格的实现&emsp;&emsp;一个未知宽高的容器，要被均分为四个相同大小格子（即四个容器），且格子间有10px间距（即十字型空隙），有哪些方法可以解决呢？ &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;方法一：（效果不好，Firefox浏览器效果基本可以，需要css微调） 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; .parent&#123; border:1px solid #CCC; margin:0 auto; width:420px; height:420px; &#125; .box&#123; background:#009999; height:200px; width:200px; display:inline-block; &#125; .box:nth-child(1)&#123; margin:0 17px 0 0; &#125; .box:nth-child(even)&#123; margin:0 0 0 -2px; &#125; .box:nth-child(3)&#123; margin:17px 17px 0 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &emsp;&emsp;方法二： （display：flex） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; width:410px; height:410px; border: 1px solid #CCC; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:space-between; &#125; .box&#123; width:200px; height:200px; background:#009999; &#125; .box3&#123; align-self:flex-end; &#125; .box4&#123; align-self:flex-end; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &emsp;&emsp;方法三：box-sizing:border-box; background-clip:content-box; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; html,body&#123;height:100%;&#125; .parent&#123; width:50%; height:50%; border: 1px solid #CCC; &#125; .box&#123; background:#009999; float:left; width:50%; height:50%; box-sizing:border-box; background-clip:content-box; &#125; .box1&#123; padding-right:10px; padding-bottom:10px; &#125; .box2&#123; padding-bottom:10px; &#125; .box3&#123; padding-right:10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 全屏布局问题：已知HTML结构和效果图如下：123&lt;div class=\"a\"&gt; &lt;div class=\"b\"&gt;Hello World&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;假设以上父元素称为A，子元素称为B &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;请写出CSS以实现以下弹窗需求：弹窗（B）固定在浏览器窗口中间，弹窗背景色为白色，弹窗宽高由其内容决定，弹窗四周为黑色半透明（0.5透明度）遮罩。 &emsp;&emsp;HTML代码： 123456789&lt;div class=\"a\"&gt; &lt;div class=\"b\"&gt; &lt;!-- 测试弹窗高度由内容决定 &lt;p&gt;Hello World&lt;/p&gt; &lt;p&gt;Hello World&lt;/p&gt; --&gt; Hello World &lt;/div&gt;&lt;/div&gt; &emsp;&emsp;CSS代码： 12345678910111213141516.a &#123; position: fixed; height: 100%; width: 100%; background-color: #000; opacity: 0.5; filter: alpha(opacity=50); &#125; .b &#123; background-color: #fff; display: inline-block; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 响应式高清屏的背景图片适配&emsp;&emsp;当我们把一个图标做成CSS中的背景图，在视网膜屏上预览时会发现图标是模糊的，所以我们会同时准备一个2倍大小的图标给高清屏，那么问题来了，怎么实现在普通屏下是普通背景图，而在高清屏下是用的高清图呢？ &emsp;&emsp;解答： 方法一：&lt;img&gt; 标签引用的图片 &emsp;&emsp;通过js做自动适配 1234567891011&lt;img class=\"photo\" src=\"./photo.jpg\" style=\"width:300px;height:200px;\" /&gt; &lt;script type=\"text/javascript\"&gt;$(document).ready(function () &#123; if (window.devicePixelRatio &gt; 1) &#123; var images = $(\"img.photo\"); images.each(function(i) &#123; var x1 = $(this).attr('src'); var x2 = x1.replace(/(.*)(\\.\\w+)/, \"$1@2x$2\"); $(this).attr('src', x2); &#125;); &#125;&#125;);&lt;/script&gt; &emsp;&emsp;Retina.js 提供了更加完善的解决方案，自动匹配屏幕分辨率的同时，还可以检测服务器上是否存有当前图片的 @2X 版本，以决定是否替换。 &emsp;&emsp;优点： 操作简单 普通屏幕下不会加载 @2X 的大尺寸图片，节约带宽 &emsp;&emsp;缺点： Retina 屏幕下，标准图片和高清的图片都会被加载 图片在显示过程中会被重绘 有些老版本浏览器下存在兼容问题（一些老版本浏览器如 IE6、7 会显示得非常失真） &emsp;&emsp;方法二：CSS的media标签 12345678@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */ only screen and (-o-min-device-pixel-ratio: 3/2), only screen and (min-device-pixel-ratio: 1.5) &#123; #logo &#123; background-image: url(./logo@2x.png); background-size: 100px auto; &#125;&#125; &emsp;&emsp;优点： 只会加载匹配当前设备的最适图片 跨浏览器兼容 &emsp;&emsp;缺点： 如果背景图片很多的话，需要编写非常冗长的代码 &emsp;&emsp;方法三：css的image-set方法1background-image: -webkit-image-set(url(./logo.png) 1x, url(./logo@2x.png) 2x); &emsp;&emsp;优点：css中编写，图片集中，代码量少&emsp;&emsp;缺点：存在兼容性问题，仅支持background-image属性，而不能使用在“”标签中，是css4的草案。 问题：完成响应式布局的实现&emsp;&emsp;已知一个自适应布局的HTML结构如下：1234&lt;div class=\"parent\"&gt; &lt;div class=\"side\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;请完成以下响应式要求： 默认情况，PC电脑（假设视窗都大于等于1000px）访问：两列布局，.parent宽960px且水平居中，左列.side宽300px，右列.main宽650px，列间距10px。 当用平板（假设视窗都大于400px且小于1000px）访问：两列布局，.parent宽度撑满，右列.main自适应剩余宽度，两列间距仍旧为10px。 当用手机（假设视窗都小于等于400px）访问：上下两行布局，.parent宽度撑满，.side和.main宽度也撑满，行间距为10px。 &emsp;&emsp;解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;完成响应式布局的实现&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt; &lt;style type=\"text/css\"&gt; html, body &#123; margin: 0; padding: 0; height: 100%; background-color: lightgray; &#125; /* 默认情况：两列布局，.parent宽960px且水平居中，左列.side宽300px，右列.main宽650px，列间距10px*/ .parent &#123; width: 960px; height: 100%; margin: 0 auto; &#125; .side &#123; float: left; background-color: lightblue; width: 300px; height: 100%; &#125; .main &#123; background-color: red; width: 650px; margin-left: 310px; height: 100%; &#125; /* 当用平板（假设视窗都大于400px且小于1000px）访问：两列布局，.parent宽度撑满，右列.main自适应剩余宽度，两列间距仍旧为10px。 */ @media screen and (min-width: 400px) and (max-width: 1000px) &#123; .parent &#123; width: 100%; &#125; .main &#123; width: auto; &#125; &#125; /* 当用手机（假设视窗都小于等于400px）访问：上下两行布局，.parent宽度撑满，.side和.main宽度也撑满，行间距为10px。 */ @media screen and (max-width: 400px) &#123; .parent &#123; width: 100%; &#125; .side &#123; width: 100%; float: none; &#125; .main &#123; width: 100%; margin-left: 0; margin-top: 10px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"side\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面优化问题：页面优化的方法 减少请求。 减少文件大小。 提升页面性能。 提升可读性，维护性。 减少请求 图片合并（62%的内容是图片） &emsp; &emsp; 1）选择合适的图片格式（PNG，JPG）。 &emsp; &emsp; 2）压缩图片（imageOptim,imageAlpha,JPEGmini） CSS合并 &emsp; &emsp; 1）多个CSS文件合并为一个。 &emsp; &emsp; 2）少量CSS样式内联 &emsp; &emsp; 3）避免使用import（同步的单线程请求）的方式引入CSS文件。 &emsp; &emsp; 4）值缩写。（margin,padding,border,border-radius,font,background） &emsp; &emsp; 5）省略值为0的单位。（0px,0%,0.5） &emsp; &emsp; 6）颜色值最短表示（red,rgb(255,255,0),rgba,#333） &emsp; &emsp;7）选择器合并(.m-logo,.m-var) &emsp; &emsp; 8）文件压缩（上线前，去空格） 页面性能优化 加载顺序（CSS放上面，JS放下面） 减少标签数量 选择器长度 耗性能属性（expression） 图片设置宽高 所有表现用CSS实现 可读性，可维护性 规范 语义化 尽量避免HACK 模块化 注释 问题：代码优化&emsp;&emsp;请对以下CSS进行优化:123456789101112131415161718192021222324252627282930h1&#123;font-weight: bold;&#125;h2&#123;font-weight: bold;&#125;h3&#123;font-weight: bold;width:100px;&#125;.g-bd&#123; border-top: 1px solid #000; border-right: 1px solid #f00; border-bottom: 1px solid #f00; border-left: 1px solid #000; color: #bbff22;&#125;.m-tab&#123; margin-top: 10px; margin-right: 10px; margin-bottom: 20px; margin-left: 10px; color: rgb(255,0,0);&#125;.m-tab li a&#123; display: block; padding: 0px 10px; font-family: \"Microsoft YaHei\", simsun; font-size: 20px; line-height: 1.5;&#125;.m-side&#123; width: 200px; background-image: url(bg.png); background-repeat: repeat-y; background-color: #ccc;&#125; &emsp;&emsp;解答： 123456h1,h2,h3&#123;font-weight: bold;&#125;h3&#123;width:100px;&#125;.g-bd&#123;border: 1px solid #000;border-color: #000 #f00 #f00 #000;color: #bf2;&#125;.m-tab&#123;margin:10px 10px 20px;color: red;&#125;.m-tab li a&#123;display: block;padding: 0 10px;font: 20px/1.5 \"Microsoft YaHei\", simsun;&#125;.m-side&#123;width: 200px;background: #ccc url(bg.png) repeat-y;&#125; 规范&emsp;&emsp;####问题：制订一份CSS规范 &emsp;&emsp;解答： 一、文件规范 1.文件按照通用类和业务类进行归档 2.文件使用外联引入，其他一些样式使用内联引入 3.文件名采用小写字母，可适当加中划线，然后使用数字来表示版本 4.编码采用utf-8格式 二、注释规范 1.块状注释：统一缩进，在被注释对象之上 2.单行注释：文字两端空格，在被注释对象之上 3.行内注释：文字两端空格，分号之后 三、命名规范 1.采用分类命名，布局类以g-开头，实际内容以m-开头 2.命名具有可读性且长度适中，适当缩写 3.语义化命名方式 四、书写规范 1.多行书写，便于阅读 2.默认缩进为两个空格 3.css规则内一个空格 4.需要保留最后一个属性值的分号 5.属性书写顺序按照：位置属性——自身盒模型相关属性——显示属性 的顺序来书写 6.尽量少使用Hack，ie6采用_开头，ie67采用*开头，先写ie67的，再写ie6的 7.color命名采用十六进制，且尽量缩写 8.url()文件格式不加引号 五、其他规范 1.&lt;!DOCTYPE html&gt; 顶格开始文档声明 2.闭合标签均闭合，自闭合标签也需要闭合 3.属性采用单引号，readonly、checked等属性可以直接写，不用=&quot;&quot; 4.采用缩进体现层级，正确嵌套，但不宜太深，影响性能 5.注释：&lt;!-- A --&gt; xxx &lt;!-- /A --&gt; 6.标签属性均小写 7.文件语义化命名，且不能过长 8.保留源文件 9.使用sprite技术来合并图片 10.图片按照模块、业务、页面来划分 模块化问题：页面模块化优点&emsp;&emsp;解答： 利于多人协同开发 便于扩展和重用 可读性，可维护性好 灵活，快速，高效.不会出现样式污染","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"Web综合","slug":"Web前端/Web综合","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/Web综合/"}],"tags":[]},{"title":"《DOM编程艺术》课堂交流问题汇总之进阶篇","slug":"《DOM编程艺术》课堂交流问题汇总之进阶篇","date":"2016-06-08T06:26:00.000Z","updated":"2018-01-21T23:12:17.850Z","comments":true,"path":"2016/0608/《DOM编程艺术》课堂交流问题汇总之进阶篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0608/《DOM编程艺术》课堂交流问题汇总之进阶篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《DOM编程艺术》学习总结 样式操作相关笔记推荐：前端微笔记-样式操作 问题一：如何实现浏览器兼容版的window.getComputedStyle window.getComputedStyle能够获取元素的实际样式，但是低版本的ie8及以下不支持，如何在低版本的ie上兼容类似的功能。 解答： 1234567function getComputedStyle(element)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(element); &#125; else &#123; return element.currentStyle; &#125; 问题二：实现getStyle函数 getStyle函数用于获取元素的实际样式，语法如下： 1var cssPropertyValue = getStyle (element, cssPropertyName)； 使用示例如下： 1getStyle(element, \"color\") 返回element元素的显示颜色，如：\"rgb(0, 0, 0)\" 1getStyle(element, \"line-height\") 返回element元素的实际行高，如：\"30px\" 请实现getStyle函数，要求浏览器兼容。 解答： 1234567function getStyle(element,cssPropertyName)&#123; if(!window.getComputedStyle)&#123; return element.currentStyle[cssPropertyName]; &#125;else&#123; return getComputedStyle(element)[cssPropertyName]; &#125; &#125; 数据通信相关笔记推荐：前端微笔记-《DOM编程艺术》-数据通信 ####问题一：Ajax请求GET方法的封装 方法 1get(url, options, callback) 参数 123url &#123;String&#125; 请求资源的urloptions &#123;Object&#125; 请求的查询参数callback &#123;Function&#125; 请求的回调函数，接收XMLHttpRequest对象的responseText属性作为参数 返回 1void 举例 123get(‘/information’, &#123;name: ‘netease’, age: 18&#125;, function (data) &#123; console.log(data);&#125;); 描述 1方法get(url, options, callback) 是对Ajax请求GET方法的封装。请写出get方法的实现代码。 解答： 123456789101112131415161718192021222324252627282930313233343536function get(url, options, callback) &#123; var xhr = new XMLHttpRequest(); //创建XHR对象 // 处理返回数据 xhr.onreadystatechange = function(callback) &#123; if (xhr.readyState == 4) &#123; //浏览器结束请求 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status == 304) &#123; //status为200-300表示success，304为读取缓存 callback(xhr.responseText); //执行返回的html、xml &#125; else &#123; alert('Requeset was unsuccessful: ' + xhr.status); &#125; &#125; &#125; // 请求参数序列化，把对象转换为例如'name1=value1&amp;name2=value2'的格式 function serialize(data) &#123; if (!data) &#123;return '';&#125; var pairs = []; for(var name in data)&#123; if (!data.hasOwnProperty(name)) &#123;continue;&#125; //判断对象自身是否有name属性 if (typeof data[name] === 'function') &#123;continue;&#125; //如果对象的值是一个函数，忽略 var value = data[name].toString(); name = encodeURIComponent(name); //把字符串作为URI 组件进行编码。将转义用于分隔 URI 各个部分的标点符号 value = encodeURIComponent(value); pairs.push(name + '=' + value); &#125; return pairs.join('&amp;'); &#125; xhr.open('get',URL,true); //url+查询参数序列号结果 //放在open后执行，表示文本内容的编码方式是URL编码，即除了标准字符外，每字节以双字节16进制前加个“%”表示 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(null); &#125; // test get('/information', &#123;name: 'netease', age: 18&#125;, function (data) &#123; console.log(data); &#125;); 问题二：Ajax请求POST方法的封装 post函数是对Ajax的POST请求的封装，语法如下：1post(url, options, callback) 没有返回值，参数说明如下：123url：请求资源的url，String类型options：请求的查询参数，Object类型callback：回调函数，接收XMLHttpRequest对象的responseText属性作为参数，Function类型 使用示例如下：123post('/addUser', &#123;name: 'jerry', age: 1&#125;, function(data) &#123; // 处理返回数据 &#125;); 请写出post函数的实现代码，要求浏览器兼容。 解答： 12345678910111213141516171819202122232425262728293031323334353637383940function PostAjax(url, options, callback)&#123; var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304)&#123; callback(xhr.responseText,options); &#125;else&#123; alert(\"Request was unsuccessful:\"+xhr.status); &#125; &#125; &#125; xhr.open(\"post\",url+\"?\"+serialize(options),true); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(null);&#125; var url=\"http://study.163.com/webDev/hotcouresByCategory.htm\"; PostAjax(url,&#123;\"id\":1002963026&#125;,function (data,options) &#123; var ObjData=JSON.parse(data); for(key in ObjData)&#123; if(ObjData[key][\"id\"]==options.id)&#123; console.log(ObjData[key]); &#125; &#125; &#125;); function serialize(data)&#123; if(!data) return \"\"; var pairs=[]; for(var name in data)&#123; if(!data.hasOwnProperty(name)) continue; if(typeof data[name]===\"function\") continue; var value=data[name].toString(); name=encodeURIComponent(value); value=encodeURIComponent(value); pairs.push(name+\"=\"+value); &#125; return pairs.join(\"&amp;\");&#125; 数据存储问题：cookie的作用和弊端 用cookie作为浏览器端的存储有哪些作用？有哪些弊端，是否有替代的解决办法？ 解答： 作用： 可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用。 保存用户的登陆状态，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。 记录用户的行为。 弊端： 增加流量消耗，因为每次请求都会带上cookie信息 安全性隐患，cookie使用明文传输 大小限制：最大容量在4KB左右","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《产品前端架构》课堂交流问题汇总","slug":"《产品前端架构》课堂交流问题汇总","date":"2016-06-05T04:36:00.000Z","updated":"2018-01-20T23:48:31.756Z","comments":true,"path":"2016/0605/《产品前端架构》课堂交流问题汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0605/《产品前端架构》课堂交流问题汇总/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《产品前端架构》学习总结 版本管理问题一：分布式版本控制(DVCS) 对比集中式版本控制系统(CVCS)&emsp;&emsp;由于Git的持续火热， 对于DVCS与CVCS的争论和对比越来越多了， 似乎很多文章都倾向于这个观点： &quot; Git这种DVCS 要比SVN这些DVCS要优越&quot; &emsp;&emsp;实际情况真的是这样吗？ 现在请同学们各抒己见， 以各个方面来分析下CVCS与 DVCS之间的优缺点. 回答： &emsp;&emsp;分布式版本控制 (DVCS) :一种不需要中心服务器的管理文件版本的方法，但是它也可以使用中心服务器。更改可以被合并到 DVCS 的任何其他用户的系统中，因此可以实现非常灵活的工作流。 主要优点： 版本控制更加灵活，因为它除了支持传统的（集中式）工作流，还支持其他各种工作流； 比集中式服务器快得多，因为大多数操作在客户机本地进行，而不需要网络操作。 &emsp;&emsp;集中式版本控制（ CVCS）：这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 优点与缺点： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。 最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 DVCS 和集中式版本控制系统的主要差异： &emsp;&emsp;在 DVCS 和集中式版本控制系统之间有三个关键差异： DVCS 通过本地提交支持离线工作，这是由 DVCS 的操作方式决定的。这与集中式版本控制完全不同，集中式版本控制要求通过到中心服务器的连接执行所有操作。这种灵活性让开发人员在飞机上也能够像在办公室中一样轻松地工作，可以一次又一次地进行提交。 DVCS 比集中式系统更灵活，因为 DVCS 支持许多不同类型的工作流，从传统的集中式工作流到纯粹的特殊工作流，再到特殊工作流和集中式工作流的组合。这种灵活性允许通过电子邮件、对等网络和开发团队喜欢的任何方式进行开发。 DVCS 比集中式版本控制系统快得多，因为大多数操作在客户机上进行，速度非常快。另外，在需要进行推（push）操作（与另一个节点通信）时，速度也更快，因为两个客户机机器上都有完整的元数据。速度差异相当显著，根据使用本地存储库还是网络存储库，DVCS 比Subversion 快大约 3-10 倍。 观点分析：“Git这种DVCS 要比SVN这些DVCS要优越” SVN属于集中化的版本控制系统，SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。SVN大都采用图形界面操作，直观，上手快。 Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。不支持中文，图形界面支持差，使用难度大。不易推广。 SVN更适用于项目管理， Git仅适用于代码管理。 一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物， 包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效。而很容易的实现了对本地代码修改的记录，而这整个过程中，根本没出现服务器。 其他详细内容参考下面推荐文章。 Git和SVN之间的五个基本区别； SVN和Git比较，哪个好用，适用？ 版本控制：SVN和GIT的一些使用感受 关于本地、集中式、分布式三种版本控制系统 分布式版本控制系统入门 问题二：在命令介绍中 多次提到的 – 是用来做什么的？在课程中， 可以发现讲师多次在命令中使用到了 – 符号， 比如 git checkout -- &lt;filename&gt; 事实上 很多时候 你使用 git checkout 也不会有问题。 那么问题来了， – 到底是用来做什么的呢？ 回答：（这个是参考别人的） --代表后面的参数是命令，如果没有--，一般指分支或者路径。 1主要是用来区分文件目录和命令的关系。 1234567891011121314151617题目中“--”后面的表示把后面连接的参数当做文件名，不管它长什么样子。它是unix的命令行规范。通常，我们使用“--”去区分后面的是一个命令还是一个参数。比如下面例子：rm -f # does nothingrm -- -f # deletes a file named &quot;-f&quot;一般我们通过使用它来区分文件名和命令参数，如果一个文件名刚好和我们常用的命令冲突了，--就可以很好的解决这个问题。通常都会加上“--”来区分使用。具体规范和标准可以看unix命令行参数语法规范标准，IEEE Std 1003.1, 2013 Edition标准Guideline 10:The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options. Any following arguments should be treated as operands, even if they begin with the &apos;-&apos; character. ####问题三：某文件在暂存区与工作目录的内容不一致时， 使用git checkout HEAD – 将导致什么结果？ 解答： 结论：git checkout HEAD – 将内容从上次提交复制到工作目录。当某文件在暂存区与工作目录的内容不一致时， 使用git checkout HEAD – 将导致工作目录被上次提交的覆盖，这时候暂存区也就没有修改了，clean掉了。其实就是本地和暂存区都被上一次的提交覆盖了。 简单实验了下，测试过程如下： 1、首先新建了一个test.txt文件，文件是空的。这时候我们将test.txt add到暂存区，此时暂存区存在新的文件test.txt。2、将暂存区的修改提交到提交区，这时候暂存区也就没有需要提交的东西了。3、本地修改test.txt文件，随便输入一些字符。此时test.txt文件大小为1KB4、此时，查看暂存区，发现暂存区存在修改文件，test.txt，这时候，test.txt文件在暂存区与工作目录的内容不一致5、执行git checkout HEAD – ，发现暂存区不存在修改文件，查看本地目录，test.txt文件已经为空，被上次提交区的空test.txt覆盖此时test.txt文件为空，0KB 问题四：为什么大部分情况下，git fetch 要优于直接使用 git pull?不难发现， 课程中对于可能常用的 git pull 命令着墨不多. 而把大量的时间放在了 git fetch + git merge 的工作原理上。 同学可以总结下，为何使用git fetch来分步骤处理 要优于直接使用git pull？ 回答： &emsp;&emsp;git pull的问题是它把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。 &emsp;&emsp;将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则git pull在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。 &emsp;&emsp;前面那些行显示出“git fetch”命令会将哪些文件下载到本地，这些文件一旦下载到本地之后，就可以在本地进行任意操作了。 &emsp;&emsp;“git fetch”命令执行完毕之后，还不会立即将下载的文件合并到你当前工作目录里，这就给你了一个选择下一步操作的机会，要是想将从远程分支下载的文件更新到你的工作目录里，你需要执行一个“合并（merge）”操作。 &emsp;&emsp;单独进行下载和合并是一个好的做法，你可以先看看下载的是什么，然后再决定是否和本地代码合并。而且分开来做，可以清晰的区别开本地分支和远程分支，方便选择使用。 文章推荐：Git 少用 Pull 多用 Fetch 和 Merge 技术选型问题一：市面上这么多种模块系统， 它们之间可以相互转换吗&emsp;&emsp;AMD、COMMONJS、CMD、UMD、ES6 Module、IIFE… 这么多的模块写法， 一旦你选择了一种模块写法，那它在另一个系统中就可能无法运行了。 值得庆幸的是，现在越来越多的工具可以帮助我们将js从一种模块写法转换为另一种写法， 你能帮助同学们列举出一个或多个转换工具吗？ 回答： 1、Browserify 12兼容 Node 模块引用语法和 Node 模块化文件加载方案, 浏览器端运行前需要完成代码的合并, 并配合 SourceMap 进行调试. 2、Webpack1它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理 3、Component1是一个对客户端 JavaScript 包进行管理的工具，用于更好的构建 Web 应用，编写模块化 commonjs 组件 4 rderjs1一个开源的 JS 按需、异步加载工具，同时也是 JS 模块化管理工具。 5 systemjs1一个最小系统加载工具。 问题二：关于通信解决方案 xhr 与 socket的取舍&emsp;&emsp;视频里介绍了一个双向实时通信解决方案socket.io。你能说出一些这种解决方案的适合场景吗？&emsp;&emsp;实时上在规范中，还有一个Server-Send-Event的规范， 可以帮助我们实现服务器端-&gt;浏览器端的反向消息推送，同学们可以下去学习一下。 回答： &emsp;&emsp;Socket.IO设计的目标是构建能够在不同浏览器和移动设备上良好运行的实时应用，如实时分析系统、二进制流数据处理应用、在线聊天室、在线客服系 统、评论系统、WebIM等。目前，Socket.IO已经支持主流PC浏览器(如IE、Safari、Chrome、Firefox、Opera等)和 移动平台上的浏览器（iOS平台下的Safari、Android平台下的基于Webkit的浏览器等）。 &emsp;&emsp;参考自《Socket.IO：支持WebSocket协议、用于实时通信和跨平台的框架》 问题三：大型的组件库为什么都用到了预处理？&emsp;&emsp;事实上处理bootstrap、foundation. 还有一些其它类似规模的组件库， 它们或许在设计和css构建上理念上有部分区别， 它们都非常一致的使用了css预处理器来管理css文件， 你能说出这么做的好处吗？ 回答： 让 CSS 更见简洁，适应性更强，代码更直观，节省了大量的重复工作和痛苦的代码编辑； 参考自：《为您详细比较三个 CSS 预处理器（框架）：Sass、LESS 和 Stylus》 缓解多浏览器兼容造成的冗余； 参考自《为什么要使用CSS预处理器？》 提供CSS缺失的样式层复用机制，提高CSS代码的可维护性 开发实践问题一：采用文档形式的规范输出有哪些弊端？&emsp;&emsp;采用文档形式的规范输出有哪些弊端？可以从协作、后续对规范的重用等方面进行讨论 回答： 假设题目里面说的是开发规范。文档类型的规范的效力依赖于开发人员的对规范的理解，和遵守规范的程度，需要再有一层QA进行保障。还有就是文档规范需要根据技术和业务的发展定期更新，更新后还要宣贯。否则可能就过时或者成为纸上的规范。尽量还是能通过工具、统一的框架、模块来规范输出。 从协助上来说：没有统一规范的管理，可能导致更新不及时，协助起来大家阅读时存在一些问题等。从后续重用性来说：文档形式的规范输出难以保证完全的统一和规范性，后续的修改和重用还需要先了解前面的具体规范再做进一步修改，学习成本更大，且容易导致问题。 问题二：实际项目中对系统进行分解的难点有哪些？&emsp;&emsp;实际项目中对系统进行分解的难点有哪些？ 回答：仁智见仁，智者见智。没有实际经验回答个毛！！ 问题三：如何根据交互提取通用组件&emsp;&emsp;如何根据交互提取通用组件？交互稿中哪些可以作为通用的组件进行封装？ 回答： &emsp;&emsp;视觉说明中包含各个情况下用户界面的显示样式，其定义了交互稿中的所有效果。之后则需要从中提取出通用组件，其中包括： 通用原件（Logo，提示，输入框，图标，按钮等） 通用列表（以网易云音乐为例，一般歌单，排行榜，收藏列表，歌手等） 复合组件（留言板类，评论控件） 浮层弹出 问题四：项目发布时需要做哪些优化？回答: 图片的优化，压缩大小 CDN的配置 代码的压缩和合并 问题五：实际项目中发布工具的哪些功能是你比较关注的？回答：仁智见仁，智者见智。没有实际经验回答个毛！！","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"Web综合","slug":"Web前端/Web综合","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/Web综合/"}],"tags":[]},{"title":"《DOM编程艺术》课堂交流问题汇总之基础篇","slug":"《DOM编程艺术》课堂交流问题汇总之基础篇","date":"2016-05-24T02:53:00.000Z","updated":"2018-01-20T23:47:28.201Z","comments":true,"path":"2016/0524/《DOM编程艺术》课堂交流问题汇总之基础篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0524/《DOM编程艺术》课堂交流问题汇总之基础篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《DOM编程艺术》学习总结 问题一：实现浏览器兼容版的element.childrenelement.children能够获取元素的元素子节点，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。 分析解答： 思路： 写一个函数getElementChild(element),传入一个父节点element. 判断DOM中element对象的children属性是否存在，存在则直接返回element.children,不存在则执行兼容代码. 兼容代码思路： 创建一个数组elementArr以便返回最终 [符合要求] 的子节点集合。 调用element对象的childNodes属性，以获取其子节点集合。 遍历子节点集合，对每一个子节点进行判断，如果节点类型为1（即节点类型为元素节点）,则添加到elementArr返回数组中。 返回数组elementArr 解决代码： 123456789101112131415// nodeType=1 元素节点 nodeType=2 属性节点 nodeType=3 文本节点function getElementChild(element)&#123; if (!element.children) &#123; //如果没有children方法 var result_elementchild = [], //新的元素子节点数组 nodelist = element.childNodes; //获取所有子节点 for (var i = 0; i &lt; nodelist.length; i++) &#123; if(nodelist[i].nodeType == 1)&#123; //判断节点是否为元素节点 result_elementchild.push(nodelist[i]); &#125; &#125; return result_elementchild; &#125; else &#123; return element.children; &#125;&#125; 问题二：实现浏览器兼容版的element.datasetelement.dataset能够获取元素的自定义属性，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。 相关文章推荐： HTML data属性简介以及低版本浏览器兼容算法 （很经典，不错的文章） HTML5自定义属性对象Dataset简介 分析解答： 思路： 找到元素中以data-开头的属性名，取到其名称。 根据dataset的驼峰命名，将data-后面的名称以驼峰命名的方式得到对应的ID名称。 构建ID名称和属性名称的键值对。 使用var attribute = element.getAttribute(attributeName)方法，从键值对中找到ID对应的属性名作为attributeName得到其对应的属性值，然后赋值给对应的ID元素。 解答： 1234567891011121314151617181920212223242526272829303132333435363738394041function $(id)&#123; return document.getElementById(id); &#125; //正则表达式变换首字母大写 function replaceReg(str)&#123; var reg = /\\b(\\w)|\\s(\\w)/g; str = str.toLowerCase(); return str.replace(reg,function(m)&#123;return m.toUpperCase()&#125;) &#125; //带兼容的函数 function get_dataset(ele)&#123; if(ele.dataset) return ele.dataset; else&#123; //一下是兼容代码 var dataset = &#123;&#125;; var ele_split = ele.outerHTML.split(\" \"); for(var i = 0,element; i &lt; ele_split.length; i++) &#123; element = ele_split[i]; if (element.substring(0,4) == \"data\") &#123; if (element.indexOf(\"&gt;\") != -1) &#123; element = element.split(\"&gt;\")[0]; &#125;; ele_key=element.split(\"=\")[0].slice(5); ele_value=element.split(\"=\")[1].slice(1,-1); if(ele_key.indexOf(\"-\") == -1)&#123; dataset[ele_key] = ele_value; &#125;else&#123; ele_keys=ele_key.split(\"-\"); ele_key=ele_keys[0]; for(i=1;i&lt;ele_keys.length;i++)&#123; ele_key+=replaceReg(ele_keys[i]); &#125; &#125; &#125;; &#125; return dataset; &#125; &#125;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《JavaScript程序设计》课堂交流问题汇总之进阶篇","slug":"《JavaScript程序设计》课堂交流区问题汇总之进阶篇","date":"2016-05-18T14:03:00.000Z","updated":"2018-01-20T23:47:16.548Z","comments":true,"path":"2016/0518/《JavaScript程序设计》课堂交流区问题汇总之进阶篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0518/《JavaScript程序设计》课堂交流区问题汇总之进阶篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《JavaScript程序设计》学习总结 问题一：复制对象&emsp;&emsp;通过课程学习我们知道，对象作为引用类型，使用运算符=时，只是复制了对象的地址。 &emsp;&emsp;比如如下代码 123var obj1 = &#123;a:1&#125;;var obj2 = obj1;obj2.a = 2; // 此时obj1.a === &emsp;&emsp;修改对象obj2同时会改变obj1，那么如果我们需要克隆出一个独立但属性、方法完全一样的对象，该如何实现？ &emsp;&emsp;解答： 使用for in 1234567var obj2=new Object(); for(var p in obj) &#123; var name=p;//属性名称 var value=obj[p];//属性对应的值 obj2[name]=obj[p]; &#125; &emsp;&emsp;参考：js中如何复制一个对象并获取其所有属性和属性对应的值 定义一个clone方法来实现 1234567891011function clone(myObj)&#123; if(typeof(myObj) != 'object') return myObj; if(myObj == null) return myObj; var myNewObj = new Object(); for(var i in myObj) myNewObj[i] = clone(myObj[i]); return myNewObj; &#125; 通过object原型扩展实现 1234567891011121314151617181920212223Object.prototype.Clone = function() &#123; var objClone; if ( this.constructor == Object ) objClone = new this.constructor(); else objClone = new this.constructor(this.valueOf()); for ( var key in this ) &#123; if ( objClone[key] != this[key] ) &#123; if ( typeof(this[key]) == 'object' ) &#123; objClone[key] = this[key].Clone(); &#125; else &#123; objClone[key] = this[key]; &#125; &#125; &#125; objClone.toString = this.toString; objClone.valueOf = this.valueOf; return objClone; &#125; &emsp;&emsp;参考：js对象复制 问题二：JS和强类型语言（比如C++）在类型方面的主要区别&emsp;&emsp;解答： &emsp;&emsp;强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 &emsp;&emsp;弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。 &emsp;&emsp;二者的区别，在于计算时是否可以不同类型之间对使用者透明地隐式转换。从使用者的角度来看，如果一个语言可以隐式转换它的所有类型，那么它的变量、表达式等在参与运算时，即使类型不正确，也能通过隐式转换来得到正确地类型，这对使用者而言，就好像所有类型都能进行所有运算一样，所以这样的语言被称作弱类型。 &emsp;&emsp;与此相对，强类型语言的类型之间不一定有隐式转换（比如C++是一门强类型语言，但C++中double和int可以互相转换，但double和任何类型的指针之间 问题三：隐式类型转换场景&emsp;&emsp;解答： 四则运算 &emsp;&emsp;加法运算符+是双目运算符，只要其中一个是String类型，表达式的值便是一个String。 &emsp;&emsp;对于其他的四则运算，只有其中一个是Number类型，表达式的值便是一个Number。 &emsp;&emsp;对于非法字符的情况通常会返回NaN： 1'1' * 'a' // =&gt; NaN，这是因为parseInt(a)值为NaN，1 * NaN 还是 NaN 判断语句 &emsp;&emsp;判断语句中的判断条件需要是Boolean类型，所以条件表达式会被隐式转换为Boolean。 其转换规则同Boolean的构造函数。比如： 12var obj = &#123;&#125;;if(obj)&#123; while(obj);&#125; Native代码调用 &emsp;&emsp;JavaScript宿主环境都会提供大量的对象，它们往往不少通过JavaScript来实现的。 JavaScript给这些函数传入的参数也会进行隐式转换。例如BOM提供的alert方法接受String类型的参数： 1alert(&#123;a: 1&#125;); // =&gt; [object Object] == &emsp;&emsp;JS的非严格匹配时会进行隐式类型转换。 问题四：识别类型方法&emsp;&emsp;解答： typeof : 可以识别除null之外的基本类型及对象类型，不能识别具体对象; 1234567typeof 1;//\"number\"typeof \"1\";//\"string\"typeof &#123;&#125;;//\"object\"typeof [];//\"object\"typeof undefined;//\"undefined\";typeof null;//\"object\"typeof true;//\"boolean\" instanceof : 可以识别Object类型和自定义类型，不能识别基本类型 1234[] instanceof Array;//true(&#123;&#125;) instanceof Object;//true(1) instanceof Object;//false(1) instanceof Number;//false constructor : 识别除null和undefined的内置类型及自定义类型 12(1).constructor===Number;//true\"1\".constructor===String;//true Object.prototype.toString().call(obj) : 可以识别标准类型以及内置对象类型；不能识别自定义对象类型； 12Object.prototype.toString().call(null);//\"[object Null]\"Object.prototype.toString().call(undefined);//\"[object Undefined]\" 组合封装函数 123456789/* * 获取对象构造函数名称 * 视频中关于getConstructorName函数写法存在bug，导致传入 0, false, \"\", NaN 这些值时，得到错误的返回结果。 * 1. 入参obj如果是undefined和null，则返回其自身; * 2. 入参obj如果是其他值，则返回obj.constructor&amp;&amp;obj.constructor.toString().match(/function\\s*([^(]*)/)[1]的结果; */ function getConstructorName(obj)&#123; return (obj===undefined||obj===null)?obj:(obj.constructor&amp;&amp;obj.constructor.toString().match(/function\\s*([^(]*)/)[1]); &#125; 问题五：函数声明和函数表达式定义同一个函数时，执行的是哪个？12345678910111213141516// 以下代码执行时，三次打印分别输出什么？为什么？ function add1(i)&#123; console.log(\"函数声明：\"+(i+1));&#125;add1(1); var add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); &emsp;&emsp;解析：1234567891011121314function add1(i)&#123; console.log(\"函数声明：\"+(i+1));&#125;add1(1); //函数声明：101 因为函数声明会被预置到代码顶部，相同的声明后一个起作用，所以调用的是下页的那个函数声明 var add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); //函数表达式：11 因为函数声明已被同名函数表达式覆盖 function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); //函数表达式：11 因为函数声明已被同名函数表达式覆盖 12345678910111213//预解析如下var add1;function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); add1(1); &emsp;&emsp;结果如下：123函数声明：101函数表达式：11函数表达式：11 &emsp;&emsp;由于这两点，程序中第一个函数和第三个函数都被提升到了前面，由于函数名相同，后一个覆盖前一个，所以起作用的只有第三个函数，同时第二个以表达式定义的函数的变量名add1也被提升到了程序的前面。 &emsp;&emsp;当第一次调用由于变量add1还没有被定义，函数定义就会覆盖掉变量add1的声明，所以执行结果是调用第三个add函数； 当调用第二个add1时，变量add1已经被定义了，所以覆盖掉了函数声明， 所以之后调用add1执行的都是 以函数表达式定义的函数add1了。 问题六：对象方法中定义的子函数，子函数执行时this指向哪里？三个问题： 以下代码中打印的this是个什么对象？ 这段代码能否实现使myNumber.value加1的功能？ 在不放弃helper函数的前提下，有哪些修改方法可以实现正确的功能？ 1234567891011var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; helper(i); &#125;&#125;myNumber.add(1); &emsp;&emsp;解析： &emsp;&emsp;1. helper中的this指向Window全局变量 &emsp;&emsp;2. 不能。因为 myNumber.value并未增加 方法一：可以把helper调整为方法函数，这样helper就可以正确引用myNumber为this了。 123456789101112 var myNumber = &#123; value:1, helper:function(i) &#123; console.log(this); this.value +=i; &#125;, add: function(i) &#123; this.helper(i); &#125; &#125;myNumber.add(1);console.log(myNumber.value); 方法二：使用闭包 123456789101112var myNumber = &#123; value: 1, add: function(i)&#123; var thisnew = this; // 构建闭包 var helper = function(i)&#123; console.log(thisnew); thisnew.value += i; &#125; helper(i); &#125; &#125; 方法三：使用方法调用模式，因为方法调用模式可以指向调用者 1234567891011121314var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; // 新建一个o对象等于myNumber,将helper方法赋值给该对象， // 然后使用方法调用模式，这样可以让helper中的this指向调用者o,即myNumber var o = myNumber; o.fn = helper; o.fn(i); &#125;&#125; 方法四：使用apply（call）调用模式，将当前helper方法借用给myNumber对象使用，这样this指向的就是myNumber对象 123456789101112var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; // myNumber对象借用helper方法，helper中的this将指向myNumber对象 helper.apply(myNumber,[i]); //apply方法 helper.call(myNumber,i); //call方法 &#125;&#125; 问题七：在变量作用域方面，函数声明和函数表达式有什么区别？&emsp;&emsp;解答： &emsp;&emsp;函数声明的执行环境为的上一层执行环境为window，函数表达式的上一层执行环境指向调用它的执行环境。&emsp;&emsp;函数声明会是全局作用域，outer指向window，函数表达式在执行时才会解析，outer指向上一级函数环境。 问题八：闭包的应用场景有哪些？&emsp;&emsp;解答： &emsp;&emsp;闭包的应用场景主要有：保存函数的状态，性能优化和封装； &emsp;&emsp;闭包有优点也有缺点，滥用闭包是非常不可取的， &emsp;&emsp;使用闭包的注意点 &emsp;&emsp;1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 &emsp;&emsp;2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 问题九：原型继承和类继承有什么区别？&emsp;&emsp;解答： &emsp;&emsp;原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。 v原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”） &emsp;&emsp;原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。 问题十：实现一个Circle类&emsp;&emsp;编程实现： 123a.创建一个圆（Circle）的类，并定义该类的一个属性（半径）和两个方法（周长和面积），其中圆的半径可以通过构造函数初始化b.创建圆的一个对象，并调用该对象的方法计算圆的周长和面积 &emsp;&emsp;解答： 12345678910111213141516function circle(r)&#123; var cir = new Object(); this.r = r; var perimeter = Math.PI * 2 * this.r; var area = Math.PI * this.r * this.r; cir.run = function()&#123; return \"圆的周长：\"+perimeter+\" \"+\"圆的面积：\"+area; &#125;; return cir;&#125;var cir1 = circle(2);cir1.run();//\"圆的周长：12.566370614359172 圆的面积：12.566370614359172\"var cir2 = circle(3);cir2.run();//\"圆的周长：18.84955592153876 圆的面积：28.274333882308138\" ###问题十一：请使用Js代码写出一个类继承的模型 &emsp;&emsp;请使用Js代码写出一个类继承的模型，需包含以下实现： 123定义父类和子类，并创建父类和子类的属性和方法子类继承父类的属性和方法在创建子类对象时，调用父类构造函数 &emsp;&emsp;解答： 12345678910111213141516171819202122function Car(brand)&#123;//父类构造器 this.brand = brand;//定义父类属性&#125;Car.prototype.getBrand = function()&#123;//定义父类方法 console.log(this.brand);&#125;;function Audi(owner)&#123;//子类构造器 Car.call(this,\"Audi\");//继承并设置父类属性 this.owner = owner;//定义子类属性&#125;Audi.prototype = new Car();//设置子类原型为父类的一个实例，则子类原型的__proto__指向父类原型Audi.prototype.constructor = Audi;//设置子类的constructor为子类构造器Audi.prototype.getBrand = function()&#123; Car.prototype.getBrand.call(this);//继承父类方法&#125;;Audi.prototype.getOwner = function()&#123;//定义子类方法 console.log(this.owner);&#125; var a4 = new Audi(\"jhl\");a4.getBrand();//Audia4.getOwner();//jhl","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《JavaScript程序设计》课堂交流问题汇总之基础篇","slug":"《JavaScript程序设计》课堂交流区问题汇总之基础篇","date":"2016-05-17T11:19:00.000Z","updated":"2018-01-20T23:47:01.380Z","comments":true,"path":"2016/0517/《JavaScript程序设计》课堂交流区问题汇总之基础篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0517/《JavaScript程序设计》课堂交流区问题汇总之基础篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《JavaScript程序设计》学习总结 问题一：获取随机整数&emsp;&emsp;获取一个大于等于0且小于等于9的随机整数？ 解答： 1234567891011// 方法一：Math.random() -- 返回0和1之间的伪随机数 可能为0，但总是小于1，即取值范围为[0,1)。 Math.floor(Math.random()*10); // 方法二 : 先取0-1的随机数，然后乘以10，获得0-10的随机数，然后向上取整，然后减1，或者乘以9，获得0-9的随机数，然后向上取整 var number=(Math.ceil(Math.random()*10))-1; var number=Math.ceil(Math.random()*9);// 方法三：先取0-1的随机数，然后乘以10，获得0-10的随机数，然后保留0位小数点，获得整数 var number=(Math.random()*10).toFixed(0);//方法四：先取0-1的随机数，然后乘以9.5，获得0-9.5的随机数，然后四舍五入，获得整数 var number=Math.round(Math.random()*9.5);//方法五：先取0-1的随机数，然后乘以10，获得0-10的随机数，然后使用parseInt进行数值转换 var number=parseInt(Math.random()*10); 问题二：字符删除&emsp;&emsp;想要去除一个字符串的第一个字符，有哪些方法可以实现？ 解答： 12345678\"hellomiaomiao\".replace(\"hellomiaomiao\".charAt(0),\"\");\"ellomiaomiao\"//运行结果\"hellomiaomiao\".slice(1);\"ellomiaomiao\"//运行结果\"hellomiaomiao\".substr(1);\"ellomiaomiao\"//运行结果\"hellomiaomiao\".substring(1);\"ellomiaomiao\"//运行结果 问题三：数组求和&emsp;&emsp;对一个数组（每项都是数值）求和，有哪些方法？ 解答： &emsp;&emsp;首先设定一个作为数据源的数组 1var arr = [1, 2, 3, 4, 5, 6,7,8,9,10]; every()方法： 123456789(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); return true;//由于every方法是会在遇到回调函数返回的第一个false时停止遍历所以需要始终返回true &#125;; arr.every(getSum); console.log(\"use every:sum = \" + sum);&#125;)(); some()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.some(getSum); console.log(\"use some:sum = \" + sum);&#125;)(); array.filter()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.filter(getSum); console.log(\"use filter:sum = \" + sum);&#125;)(); array.map()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.map(getSum); console.log(\"use map:sum = \" + sum);&#125;)(); array.froEach()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.forEach(getSum); console.log(\"use forEach:sum = \" + sum);&#125;)(); array.reduce()正向归并方法： 123arr.reduce(function(prevResult, item, index, array) &#123; return prevResult += item; &#125;); array.reduceRight()逆向归并方法： 123arr.reduceRight(function(prevResult, item, index, array) &#123; return prevResult += item; &#125;); for循环方法 123456(function() &#123; for (var i = 0, sum = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; console.log(sum); &#125; console.log(\"use for:sum = \" + sum);&#125;)(); while循环方法 12345678(function()&#123; var i = 0, sum = 0; while(i&lt;arr.length)&#123; sum+=arr[i]; console.log(sum); i++; &#125; console.log(\"use while:sum = \" + sum);&#125;)(); for -in方法 1234567(function() &#123; var sum = 0; for (var index in arr) &#123; sum += arr[index]; console.log(sum); &#125; console.log(\"use for-in:sum = \" + sum);&#125;)(); forEach()方法 1234567var calc = &#123; sum: 0&#125;; function getSum(item, index, array) &#123; this.sum += item; console.log(this.sum); &#125; arr.forEach(getSum,calc); console.log('use forEach and change this:sum=' + calc.sum); join()方法 12eval(arr.join(&quot;+&quot;)); /*这里先将所有数组项通过字符串&quot;+&quot;连为一个字符串&quot;1+2+3+4+5+6&quot;，然后返回的这个字符串传给eval()方法，eval()方法接收了这段字符串后，就直接将这段字符串中的代码放在当前作用域下执行了。*/ 重点相关文章推荐：《数组求和方法比较 》 问题四：量词&emsp;&emsp;正则表达式中，量词的贪婪模式与惰性模式有什么区别？ 解答： &emsp;&emsp;贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 &emsp;&emsp;贪婪量词：先看整个字符串是否匹配，如果不匹配就把最后一个字符去掉在进行匹配，不匹配继续去掉最后一个字符，指导找到一个匹配或者不剩任何字符才停止。 &emsp;&emsp;惰性量词：先看第一个字符串是否匹配，如果第一个不匹配就在加入第二个字符串依此类推，指导找到一个匹配或者不剩任何字符才停止，贪婪量词与贪婪量词的方法正好相反. &emsp;&emsp;浏览器对量词的支持还不完善，IE和OPERA都不支持量词，MOZILLA把支配量词看作是贪婪的。 &emsp;&emsp;参考文章： 正则表达式之 贪婪与非贪婪模式详解（概述）； JS-正则量词的贪婪、惰性 问题五：JSON.stringify兼容&emsp;&emsp;JSON.stringify函数在ie6/7中不支持，如何兼容？ 解答： jQuery插件支持的转换方式： 1$.parseJSON( jsonstr ); //jQuery.parseJSON(jsonstr),可以将json字符串转换成json对象 Javascript支持的转换方式： 1eval('(' + jsonstr + ')'); //可以将json字符串转换成json对象,注意需要在json字符外包裹一对小括号 &emsp;&emsp;注：ie8(兼容模式),ie7和ie6可以使用eval()将字符串转为JSON对象，但不推荐这些方式，这种方式不安全eval会执行json串中的表达式。 JSON官方的转换方式： &emsp;&emsp;http://www.json.org/提供了一个json.js,这样ie8(兼容模式),ie7和ie6就可以支持JSON对象以及其stringify()和parse()方法；可以在https://github.com/douglascrockford/JSON-js上获取到这个js，一般现在用json2.js。123&lt;!--[if lt IE 9]&gt; &lt;script src=\"json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; &emsp;&emsp;这样JSON.stringify 便可以正常使用！ 判断类型加算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function forIn(obj, handler) &#123; for (var i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; handler(i, obj[i]); &#125; &#125;&#125;function each(arr, handler) &#123; for (var i = 0, len = arr.length; i &lt; len; i += 1) &#123; handler(i, arr[i]); &#125;&#125;if (!JSON) &#123; JSON = &#123;&#125;;&#125;if (!JSON.parse) &#123; JSON.parse = function(json) &#123; return eval('1,' + json) &#125;;&#125;if (!JSON.stringify) &#123; (function(JSON) &#123; var arr = '[object Array]', obj = '[object Object]'; JSON.stringify = function(json) &#123; var t = ''; var m = Object.prototype.toString.call(json); if (m == arr) &#123; t = ArrPartten(json); &#125; else if (m == obj) &#123; t = ObjectJson(json); &#125; else &#123; t = json; &#125; return t; &#125; function ObjectParse() &#123; var t = '&#123;'; forIn(json, function(i, ele) &#123; var m = Object.prototype.toString.call(ele); if (m == arr) &#123; t += i + ':' + ArrPartten(ele) + ','; &#125; else if (m == obj) &#123; t += i + ':' + ObjectJson(ele) + ','; &#125; else &#123; t += i + ':' + ele + ','; &#125; &#125;); if (t.length != 1) &#123; t = t.substring(0, t.length - 1); &#125; return t + '&#125;'; &#125; function ArrayParse() &#123; var t = '['; each(json, function(i, ele) &#123; var m = Object.prototype.toString.call(ele); if (m == arr) &#123; t += ArrPartten(ele) + ','; &#125; else if (m == obj) &#123; t += ObjectJson(ele) + ','; &#125; else &#123; t += ele + ','; &#125; &#125;); if (json.length &gt; 0) &#123; t = t.substring(0, t.length - 1); &#125; return t + ']'; &#125; &#125;(JSON));&#125; 判断类型加算法实现（版本二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if(!window.JSON)&#123; window.JSON = &#123; parse: function(sJson)&#123; return eval(\"(\" + sJSON + \")\"); &#125;, stringify: function(obj)&#123; var result = \"\"; for(var key in obj)&#123; if(typeof obj[key] == \"string\")&#123; // 如果属性值是String类型，属性值需要加上双引号 result += \"\\\"\" + key + \"\\\":\\\"\" + obj[key] + \"\\\",\"; &#125;else if(obj[key] instanceof RegExp)&#123; // 如果属性是正则表达式，属性值只保留一对空大括号&#123;&#125; result += \"\\\"\" + key + \"\\\":&#123;&#125;,\"; &#125;else if(typeof obj[key] == \"undefined\" || obj[key] instanceof Function)&#123; // 如果属性值是undefined, 该属性被忽略。忽略方法。 &#125;else if(obj[key] instanceof Array)&#123; // 如果属性值是数组 result += \"\\\"\" + key + \"\\\":[\"; var arr = obj[key]; for(var item in arr)&#123; if(typeof arr[item] == \"string\")&#123; // 如果数组项是String类型，需要加上双引号 result += \"\\\"\" + arr[item] + \"\\\",\"; &#125;else if(arr[item] instanceof RegExp)&#123; // 如果属数组项是正则表达式，只保留一对空大括号&#123;&#125; result += \"&#123;&#125;,\"; &#125;else if(typeof arr[item] == \"undefined\" || arr[item] instanceof Function)&#123; // 如果数组项是undefined, 则显示null。如果是函数，则显示null?。 result += null +\",\"; &#125;else if(arr[item] instanceof Object)&#123; //如果数组项是对象(非正则，非函数，非null)，调用本函数处理 result += this.stringify(arr[item]) +\",\"; &#125;else&#123; result += arr[item] + \",\"; &#125; &#125; result = result.slice(0,-1)+\"],\" &#125;else if(obj[key] instanceof Object)&#123; // 如果属性值是对象(非null，非函数，非正则)，调用本函数处理 result += \"\\\"\" + key + \"\\\":\" + this.stringify(obj[key]) + \",\"; &#125;else&#123; result += \"\\\"\" + key + \"\\\":\" + obj[key] + \",\"; &#125; &#125; // 去除最后一个逗号,两边加&#123;&#125; return \"&#123;\" + result.slice(0,-1) + \"&#125;\"; &#125; &#125;;","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/"},{"name":"JavaScript","slug":"Web前端/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/Web前端/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]}]}
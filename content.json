{"meta":{"title":"后乐","subtitle":"柴门闻犬吠，风雪夜归人","description":null,"author":"ZiZhi Cao","url":"https://sophoraflower.github.io/EverQuest"},"pages":[{"title":"About Hueman","date":"2018-01-15T11:49:53.883Z","updated":"2018-01-15T11:49:53.883Z","comments":true,"path":"about/index.html","permalink":"https://sophoraflower.github.io/EverQuest/about/index.html","excerpt":"","text":"Probably the most beautiful theme for Hexo. Preview This theme is ported from AlxMedia‘s the WordPress theme Hueman.Special thanks to AlxMedia, who designed the original theme Hueman for wordpress.View DocumentationIt is strongly recommended that you read the docs before using Hueman. FeaturesResponsive LayoutHueman knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Categories inside Main MenuHueman inserts your blog categories into main menu in the header section. You can enable/disable this feature in menu setting. Self-hosted Insite Search EngineWith the help of Insight Search, you can search anything inside your site without any third-party plugin. Custom Comment ServicesHueman supports several comment services, give you better choices to communicate with your readers. ThumbnailHueman uses the thumbnail front-matter option to set the thumbnail for a post. If the post does not have a thumbnail option, Hueman will find the first image in the post as the thumbnail. You can enable/disable this feature in thumbnail setting. Code HighlightHueman has more than 60 themes imported from Highlight.js, and it is very easy to customize your own highlight theme. lightgalleryHueman uses lightgallery.js to showcase your photos. Just enable it in your configuration, and that’s all! SidebarHueman provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. And so many new features to be explored…View Documentation"}],"posts":[{"title":"年末小记","slug":"年末小记","date":"2017-11-30T12:08:08.000Z","updated":"2018-01-20T13:29:53.211Z","comments":true,"path":"2017/1130/年末小记/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/1130/年末小记/","excerpt":"","text":"2017年11月30日 python代码500~1000行 《Python核心编程》- 正则表达式 Python3 + requests + cookies：模拟用户登录/登录接口测试/多用户模拟 职业规划（12月待考虑问题） 语言选择问题：C还是C++还是JAVA？ 日本IT市场（互联网、游戏、公司、开发环境、成长空间、对比国内） 深造的可能性（AI、大数据） 语言问题（N2、N1准备，托业准备） 什么时候去日本、待的时间、回国后怎么发展、婚姻、家庭、子女成长及教育 …… 2017年12月01日 需要登录接口测试用例模板 JMeter压力测试 + 自动化（Jenkins + Ant + JMeter） HTTP协议 CSDN学习日志每周汇总（争取每个月总结不少于10篇） 职业规划（12月待考虑问题） 语言选择问题：C还是C++还是JAVA？ 高级测试的发展前景 托业学习计划 淘宝、蚂蚁金服、阿里云、支付宝准备（明年七月~九月）：招聘要求、技能 工作日及周日时间安排 ​ 2017年12月02日 熟悉使用JMeter等性能测试工具，有二次开发经验优先； 熟悉使用Linux系统； 熟悉Nginx、Redis等应用服务器配置与管理； 熟悉掌握MySQL、mongodb等常用数据库系统的操作，能熟练编写复杂SQL语句； 大型网站性能测试经验； 深入了解HTTP、TCP/IP等网络协议，熟悉J2EE Web系统，熟悉掌握多种中间件（Tomcat、Apache、Nginx、MQ等）各项性能参数设置、监控及优化； Web安全、安全测试、渗透测试 shell、javascript、Python 脚本语言 Java语言 计算机基础（长久性学习） ​ 2017年12月03日 Java（核心） &gt; Web方向 计算机基础（计算机网络、操作系统、计算机组成原理、算法、数据库） Python开发（自动化测试、爬虫、数据分析、Web） 数据可视化、性能测试 Language：English &gt; TOEIC","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"小记","slug":"技术/小记","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/小记/"}],"tags":[]},{"title":"D3.js小结","slug":"D3.js 小结","date":"2017-05-28T13:13:00.000Z","updated":"2018-01-20T13:32:36.691Z","comments":true,"path":"2017/0528/D3.js 小结/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/0528/D3.js 小结/","excerpt":"","text":"D3：数据可视化库(D3 4.0+)&emsp;&emsp;D3是目前最流行的JavaScript可视化图表库之一，D3的图表类型非常丰富，并且支持SVG格式，因此应用十分广泛，也有很多图表插件基于D3开发，比如MetricsGraphics.js，在D3上构建的数据图表非常强大。1234567// 引用D3对象// select()方法返回一个对DOM中匹配的第一个元素的引用d3.select(\"body\") // append()会创建一个新的DOM元素,然后把它追加到调用它的元素末尾 .append(\"p\") // text()接受一个字符串，把它插入到当前元素的开始和结束标签之间 .text(\"New paragraph!\") 123456789d3.select(\"body\") // 选择DOM中的所以段落。没有段落时，返回空元素 .selectAll(\"p\") // 解析并输出数据值 .data(dataset) // 创建新的绑定数据的元素（占位元素） .enter() .append(\"p\") .text(\"New paragraph\"); 数据加载CSV数据1234567891011d3.csv(&quot;xxx.csv&quot;, function(error, data)&#123; if (error) &#123; console.log(error); &#125; else &#123; // 把CSV数据交给全局变量 dataset = data; // 调用生成可视化图标的其他函数 generateVis(); hideLoadingMsg(); &#125;&#125;) 加载JSON数据1234d3.json(&quot;waterfallvelocities.json&quot;, function(json)&#123; console.log(json); // todo json data&#125;) SVG12345678910111213141516171819202122232425262728// 创建SVG元素var w = 500, h = 70;var svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h);var dataset = [5, 10, 15, 20, 25];// 创建圆形var circles = svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\");// i为从0开始的整数，d为dataset[i]circles.attr(\"cx\", function(d, i)&#123; return (i * 50) + 25; &#125;) .attr(\"cy\", h/2) .attr(\"r\", function(d)&#123; return d; &#125;) // 填充 .attr(\"fill\", \"yellow\") // 描边 .attr(\"stroke\", \"orange\") .attr(\"stroke-width\", function(d)&#123; return d/2; &#125;); &emsp;&emsp;&emsp;&emsp; 条形图1234567891011121314151617181920212223242526272829&lt;script&gt; var w = 500, h = 100, barpadding = 1; var dataset = [ 15, 20, 13, 15, 17, 19, 60, 55, 34, 19, 57, 99, 55, 61, 77, 64, 81, 56, 33, 24 ]; var svg = d3.select(\"body\").append(\"svg\").attr(\"width\", w).attr(\"height\", h); // 创建矩形 svg.selectAll(\"rect\").data(dataset).enter().append(\"rect\") .attr(\"x\", function(d, i)&#123; return i * (w / dataset.length); &#125;).attr(\"y\", function(d)&#123; return h - d; &#125;).attr(\"width\", w / dataset.length - barpadding).attr(\"height\", 100) .attr(\"fill\", function(d)&#123; return \"rgb(0, 0, \" + (d * 10) + \")\"; &#125;); // 值标签 svg.selectAll(\"text\").data(dataset).enter().append(\"text\") .text(function(d)&#123; return d; &#125;) .attr(\"x\", function(d, i)&#123; return i * (w / dataset.length) + 11; &#125;) .attr(\"y\", function(d)&#123; return (h-d) + (h-(h-d))/2 + 2; &#125;) .attr(\"font-family\", \"sans-serif\") .attr(\"font-size\", \"11px\") .attr(\"fill\", \"white\") // 水平居中文本 .attr(\"text-anchor\", \"middle\");&lt;/script&gt; 比例尺和数轴创建通用的数轴函数原写法： 123var xAxis = d3.svg.axis();xAxis.scale(xScale);xAxis.orient(bottom); 最新写法 123var xAxis = d3.axisBottom().scale(xScale);var yAxis = d3.axisLeft() .scale(yScale); 创建线性比例尺原写法： 1var xScale = d3.scale.linear().domain([0, 100]).range(0, 10); 最新写法： 1var xScale = d3.scaleLinear().domain([0, 100]).range(0, 10); 散点图示例1234567891011.axis path,.axis line &#123; fill: none; stroke: black; shape-rendering: crispEdges;&#125;.axis text &#123; font-family: sans-serif; font-size: 11px;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 //Width and height var w = 500; var h = 300; var padding = 30; //Dynamic, random dataset var dataset = []; //Initialize empty array var numDataPoints = 50; //Number of dummy data points to create var xRange = Math.random() * 1000; //Max range of new x values var yRange = Math.random() * 1000; //Max range of new y values for (var i = 0; i &lt; numDataPoints; i++) &#123; //Loop numDataPoints times var newNumber1 = Math.floor(Math.random() * xRange); var newNumber2 = Math.floor(Math.random() * yRange); dataset.push([newNumber1,newNumber2]); &#125; //Create scale functions var xScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[0]; &#125;)]) .range([padding, w - padding * 2]); var yScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[1]; &#125;)]) .range([h - padding, padding]); var rScale = d3.scaleLinear() .domain([0, d3.max(dataset, function(d) &#123; return d[1]; &#125;)]) .range([2, 5]); //Define X axis var xAxis = d3.axisBottom() .scale(xScale) .ticks(5); //Define Y axis var yAxis = d3.axisLeft() .scale(yScale) .ticks(5); //Create SVG element var svg = d3.select(\"body\") .append(\"svg\") .attr(\"width\", w) .attr(\"height\", h); //Create circles svg.selectAll(\"circle\") .data(dataset) .enter() .append(\"circle\") .attr(\"cx\", function(d) &#123; return xScale(d[0]); &#125;) .attr(\"cy\", function(d) &#123; return yScale(d[1]); &#125;) .attr(\"r\", function(d) &#123; return rScale(d[1]); &#125;); //Create labels svg.selectAll(\"text\") .data(dataset) .enter() .append(\"text\") .text(function(d) &#123; return d[0] + \",\" + d[1]; &#125;) .attr(\"x\", function(d) &#123; return xScale(d[0]); &#125;) .attr(\"y\", function(d) &#123; return yScale(d[1]); &#125;) .attr(\"font-family\", \"sans-serif\") .attr(\"font-size\", \"11px\") .attr(\"fill\", \"red\"); //Create X axis svg.append(\"g\") .attr(\"class\", \"axis\") .attr(\"transform\", \"translate(0,\" + (h - padding) + \")\") .call(xAxis); //Create Y axis svg.append(\"g\") .attr(\"class\", \"axis\") .attr(\"transform\", \"translate(\" + padding + \",0)\") .call(yAxis); 更新，过渡和动画交互式图表布局地图","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"数据可视化","slug":"技术/数据可视化","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/数据可视化/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"软件测试管理","slug":"软件测试管理","date":"2017-04-24T15:35:00.000Z","updated":"2018-01-20T13:23:50.372Z","comments":true,"path":"2017/0424/软件测试管理/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2017/0424/软件测试管理/","excerpt":"","text":"文章依据《我是怎样做测试管理的？》，《测试管理的一点心得体会》，对测试管理过程做了简单的描述和总结。 情景再现有方法与无方法&emsp;公司现状：创业公司，误打误撞进了软件这一行当，但软件这行是否可以持续走，是否要持续走，BOSS还不确定，如果卖的不好就不做软件了，改做别的。现在是生存阶段，有项目就接上。上面有BOSS关系搞定，下面有老实的干活人努力加班，项目也就过得去。 &emsp;软件测试：公司发动了所有实施顾问来测试，只有他们通过，才能去实施。实施顾问大多来自刚刚毕业的应届毕业生，对企业管理，对软件，对行业领域，都一无所知。对测试更是一窍不通。测试并没有分工，每个人都测试软件。也没有什么测试方法，也没有什么测试计划，也不知道该测什么。反正也是对软件不了解，就当是深入学习软件。 &emsp;遇到问题：开始并没有测试报告，大家发现问题，就用电话或QQ或邮件，把问题发给开发人员。谁认识那个开发人员，就发给那个开发人员，如果不认识一个开发人员，就发给老板了。报告中尽是不好用，不能用的词汇。但什么功能不好用，是怎么操作导致不好用，不好用的具体表现是什么，都没有。老板急眼了，怎么这么多问题。 &emsp;原因分析： 很多问题都是每个人都反映了，其实只有一个问题，只不过大家没有分工，都测试，于是都报告； 不少人见一个问题发一个邮件，所以看起来很多； 有的人测试只是随便乱点乱输入，咱们软件还没有做这种破坏性操作兼容防范； 不少人不了解功能，不了解行业，不了解业务，本来是对的，按他的理解是错的； 有些人偷懒，今天发的是这些问题反馈，后天又是同样。 &emsp;解决措施： 分工测，几个人测试一块功能； 不全部测，只测试那些很常用的重点功能； 不要电话、QQ、邮件来报告给单独的开发人员，给我一个人发就可以了，我来判断衡量安排。也不要随时报告。每天下班的时候来统一发送，由各个测试小组的负责人来汇总自己组内的测试，并且把重复的问题合并掉； 每个测试小组的每天的测试报告要连续在一起，不要今天发今天的测试EXCEL，明天是明天的测试EXCEL，这样没有连贯性； 每个问题，要标好功能模块，有测试人，有测试版本号，有测试时间，有测试操作过程，有测试输入数据，有报错截图； 先测试正常的数据输入，正常的操作流程，是否能全部流程走通，是否数据保存正常，是否保存后的数据还能正确的取出来。那些临界条件测试先不要做。对于功能不易操作、界面不好看、起的窗口标题是否得当，字体是否加粗这些需求不要提。咱们目前阶段的重点是测试问题，不要把需求和找问题混在一起。 巧妇难为无米之炊&emsp;公司现状：第一批客户的实施终于启动了，实施顾问奔向了全国。随着项目的实施，公司渐渐拢回来不少钱，但是面临了一个瓶颈，这个大项目快做完了，以后有什么活能养活现在这么多人呢。所以，最好的做法就是把现在这个项目产生的软件改改，变成一个产品，卖给其他的客户，卖的越多越好。但是，其他客户我们有关系的并不多，所以要想销售给其他客户，必须拿产品说话。于是，研发部陆续加入了专职的测试人员、文案人员、美工人员，旨在提高产品的质量和包装，希望能卖个好价格。所以说，专职的测试人员是这么来的。 &emsp;软件测试：很多软件公司没有测试人员，其原因就是老板搞定关系，程序员老实干活，项目质量虽然不行，但也能将就把钱结了。既然能赚钱，干嘛要测试人员呢。除非由于质量问题，签不到单子。除非由于质量问题，客户不验收不给尾款。除非公司所有人都测试还是无法达到客户满意的质量。只有这样，才会招聘专职的专业的测试人员。测试人员一来了，开始工作。但怎么开展测试呢？文档在哪里？ &emsp;遇到问题： 对测试，对软件，对业务的理解肤浅。过去发现的问题都是小儿科，真正复杂的问题根本没有测试到。给客户一讲解，客户一问，发现原来很多功能细节没有理解，不知道怎么给客户解释； 文档只有很老的设计文档，现在软件和文档已经毫无关系； 测试人员硬着头皮，开始学习软件，什么是正确的什么是不正确的，测试人员也不知道，当然也不知道BUG究竟是什么样。软件质量仍然没有改进。 帮助在哪里？没有？因为没有写帮助文件的人。只有打单的时候讲解的PPT； 改进初期，测试来测试去，其测试结果和实施人员的测试没多大区别，都还是在门外转。 老板问：这个测试人员是不是没啥能力？要不要裁掉？ &emsp;原因分析： 实施顾问对软件本身的理解思路和自身的理解层次，其次是用户（客户）理解能力的高低及要求； 都是程序员，谁来专门写文档。为了公司生存，我身兼数职，到处开会做项目经理或做售前，还管开发人员，还有实施人员给我打电话问软件中某个功能怎么回事，我也分身无术；都是根据实施人员、客户、销售人员、老板反映的需求和BUG修改。那些BUG和需求EXCEL表格倒是有，但没法作为测试案例编写的根据。 没有写帮助文件的人。只有打单的时候讲解的PPT。 由于几年发展，软件加入了大量客户的需求，很多细节的东西在帮助中也没有看到，测试人员也不知道有这个功能。 &emsp;解决措施： 一方面仍然要求他们按照过去的测试问题报告流程和方法来报告实施现场中发现的问题，另一方面我自己写了FAQ给实施顾问发出去。但是实施顾问仍然问，一个问题重复的问。我说你看FAQ的第XX行。他说他看了，但没看明白（其实是对客户业务不了解，所以也不明白功能）。我就给他再解释。经过多次解释，我也了解了实施顾问的理解思路和理解层次，于是不断修正FAQ，使FAQ1.0、FAQ1.1.1这样不断发布，几乎天天发布。我现在回过头来想，帮助文件写的好不好，不能你说你自己已经写的很明白了傻瓜才看不懂，不要这样认为，这样根本不解决问题。唯一的方法就是用户理解能力有多低，你就要把帮助写的有多低，让他理解是目的，要不你还能怎样呢，就这样的人，问题还得解决。 文案人员也不了解软件，她写出来的也是自己猜测，所以我已经分出来一个开发人员做项目经理，他目前专门负责把帮助文档建立起来，但是他开发人员出身不擅长写文档，但他熟知软件，所以只有他们两个人搭配才能搞定。但这种磨合，需要时间。 测试人员硬着头皮，一边测试人员瞎学习瞎测试，一边项目经理和文案人员不断讲解不断编写不断审核不断修改。 巧妇难为无米之炊。果不其然，测试人员有其独到的软件测试方法、软件理解方法。很快，测试人员对软件的理解不亚于那些多年的实施顾问，也不亚于程序员。找问题也越来越准确，越来越深入。当然，其原因也在于这个团队的成长，有专职的项目经理开始书写现有功能需求修改的设计文档。过去的，没有的，就让它过去，就让它缺失吧，但未来，不要成为过去。现在也有专职的文案，不断在修改帮助，加深了许多。测试人员现在比文案人员理解功能更细，更深入，经常提醒文案人员应该把某句话写进帮助中，否则容易被用户忽略，是个不小心就会绊倒的坑。 各司其职。对症下药&emsp;遇到问题：在过去，服务部小姑娘老把电话转给开发人员，本来就几条枪，被客户电话吵的无法安心开发。而且客户发现开发人员接听电话处理问题更有效，所以很多客户都是直接给开发人员打电话，服务部成了虚架子，而开发人员的开发进度被拖累，叫苦不迭。 &emsp;解决措施：为了使测试人员更快速的了解客户应用操作方法，更细节的了解特个性的功能，我让测试人员也兼任研发部的技术支持。现在有了测试人员兼任技术支持，这下解放了开发人员。开发的质量和速度提高许多。 &emsp;引发问题：测试人员并没有做技术支持的经验，过了段时间就来和我诉苦，说现在服务部小姑娘啥也不干，都直接把电话转到他这里来，所以他现在已经无法测试了，成了专职的服务支持人员。如果再这样下去，软件质量无法保证，以后的技术支持压力更重，开发部就会成为开发+服务部门。 &emsp;解决措施（针对测试）： 经常遇到的问题，就做成FAQ。下一次还有小姑娘问，直接让她看FAQ，拒不回答。 交给他们方法和思路，不替他们亲自做。亲自看着她，让她服务支持客户。一次不会，再继续这样做第二次，必须让她自己亲自会了。 每个星期六定期培训，疑问解答。并且考试。如有讲过后考试还不会者，扣钱。 &emsp;解决措施（针对服务部门）：你接待了多少客户问题，解决时间多长，多少个问题转给开发部技术支持了，这些问题的难度级别多高。根据这些指标来衡量服务部小姑娘们的技术解决问题能力。能力差的就辞退。 统一战线，旗帜分明&emsp;遇到问题：于有时候客户报告了某个BUG，程序员一看好改就直接改掉了，改完后就直接联系客户更新了，但是并没有更改软件版本号，也没有做新的打包。于是出现了同一个版本号软件功能表现却不同。而且，由于项目组多了，每个项目组组长都各有各的原因，有时候自己就打了一个包给了客户，随便定个版本号，起的都稀奇古怪，有的叫beta版，有的叫6.0.20050203。这种情形导致了测试人员做测试的时候，开发人员说改了，测试人员说没改。开发人员说已经没有问题了，测试人员说我这里还能重复出来。于是两个人一起查，耗费了两天时间，才查出来测试人员手里的和开发人员手里的不一致。 &emsp;解决措施： 开发人员绝对不能接触客户，不能接听客户电话，也不能解决客户问题，更不能给客户更新； 开发人员不能没有任务分配和设计文档就擅自修改软件，否则记过处分； 大家一致使用版本管理工具、BUG管理工具、需求管理工具、任务管理工具。用工具把项目经理、开发人员、测试人员、文案人员绑定在一起，按固化流程推进流转； 打包发布统一交给测试人员来做，测试人员来控制是否可以发布，发布的版本号的命名。质量达不到，有权不能发布。 有的放矢，步步为营&emsp;&emsp;我们的测试已经能做边界测试、版本兼容性测试、系统兼容性测试、压力测试、安全测试、集成测试、破坏性测试。也已经在项目中应用全程测试，测试人员主要参与需求验证、设计验证、代码验证、文档验证、打包验证。 &emsp;&emsp;但是，我们现在还没有实现单元测试，开发人员就这些人，项目却多。而且测试人员没有编程能力。我们也没有做更多的回归测试，毕竟测试人员数量配备太少，而项目并行太多。 &emsp;&emsp;看机会吧。老板越从软件上赚钱，他才会越舍得投入软件。成本永远嫌多，利润永远嫌少。 &emsp;&emsp;如果你是一名开发主管，你的老板还没有从你负责的软件中赚钱，而且是很快乐的很大规模的赚钱，而不是他靠他的人际关系和送礼吃饭支撑着，我想，他不会给你一毛钱的。你抱怨也没有用，因为你没有价值，所以投入也是没有意义。 &emsp;&emsp;先去证明你的价值吧。 测试管理总结 1、组间合作 与开发、实施等组间良好的沟通与配合是非常重要的。这需要大家对目标认识的一致性及相互的理解与包容。实施人员直接面对的是用户，他们提出的任务不多，但都是比较重要的，需要直接交付于用户的。往往也是比较紧急的，所以沟通时必须确认好交付时间，以最高优先级来处理并以高质量来完成。 测试负责人不仅仅是关注测试那部分的工作，也需要关注整个项目的动态。实时了解项目的进度，了解每个阶段用户使用相对较多的模块，以了解本阶段的主要工作，把握本工作的重点，也能提前作好准备工作。同时发现项目在哪方面存在问题时，也可以用巧妙的方式来提醒，让他知道你是好意而不是对他工作的否定。如果经常能帮助到他们，我想对方也会欣然接受。 2、测试负责人的工作职责 沟通协调工作也必须做好，当多个任务同时提交时，一定要问清楚紧急程度，系统是否要急于发布，文档是否急于交付。不急于发布的也可以让先发布好环境，因为往往发布系统都需要一定的时间，在其它系统没发布好前可以先进行测试。每项任务都需要了解范围，预计需要投入的工作及计划安排的人员。同时要做好突发性任务的准备。 测试负责人要有计划性和预见性，根据之前项目的经验判断出在某个阶段会有哪些工作要做，在任务不是很繁忙的时候要提前去做，这个是非常重要的。像文档能准备的尽早准备，交付前稍做检查更新就好了。在上线前一般系统会非常忙，根本没时间去修改文档等其它工作。 重要的任务需要亲自把关，或安排信得过的人去检查。对于客户交付的文档对于内容和格式都务必要正确。像用户手册等是用户需要使用的，所以内容的正确性与现有系统的一致性就比较重要。对于测试用例、缺陷记录、出厂测试报告等文档的内容用户不是太关心的，格式则比内容更重要。对于发布前的那次测试一定要进行整体测试。不要相信因开发说哪些地方没改不会存在问题的说法，对于修改的模块或功能，与之相关的功能进行重点测试，未涉及到修改的模块也要把每个功能简单测试一下。开发修改缺陷时经常会把关联的地方没关注到，还有经常作了一些小的改动没有提交测试，时间久了就忘了哪些地方作了修改了。 把合适的人放在合适的位置。团队的每一位成员特长不可能都会一样，每个方面不可能同样的优秀。有些可能是技术方面强一些，有些在业务方面要强一些，有的可能在管理方面要强一些；有的性格开朗善于沟通，有的不善言辞但敏于思考，能耐得住寂寞。前者可以多做些沟通及工作协调的事，后者可以多安排些技术研究或检查文档等需要细心一点的工作。当然也要让组员明白，不是自己想要做什么就能做什么，一切必须以当前的任务情况来做安排，在条件许可的情况下会优先考虑。自己可以利用业余的时间去学习，充实自己，一旦机会来临才能去胜任。 要善于观察组内成员的工作状态，及时发现哪些人状态不好，及时沟通及协助解决。 要定期向上级领导汇报工作情况，让领导了解组内的工作情况，同时当需要申请资源时也会容易些。同时也需要让组员了解一下自己的工作情况，他们可能只了解你参与测试的这部分工作，其它工作并不了解。不要让组员认为什么事都让下面人做，自己却没做多少事。 3、组内管理 一个好的团队必须有良好的团队氛围，必须要有共同的目标，这点很重要。如果经常意见不一致在喋喋不休地争论，这样什么事情都不可能做好。当然这并不代表大家不能发表自己的意见。讨论问题时大家都是平等的，要尽情开放的地讨论，把大家的建议都发表出来，最后采取的方案也要取得大多数人的认同，但一旦确定一个执行方案后大家都要按照来执行。 要合理安排资源，以免部分人员工作强度很高，部分人员又会有空闲时间。这样也会引起忙的人心里不平衡。这个是有点难度，但需要尽可能地安排好。每个项目的测试人员要多考虑一两个备份人员，具体人数视项目情况。每个阶段每个项目的工作量都不一样，安排时根据每个项目进度情况来合理备配人员，尽量做到大家的工作量不会出现太大的差异。当任务少时，可以多安排一些研究性的工作为一个阶段的工作做准备，多安排业务交流，文档走查的工作等，也可以对前段时间的工作总结。像年初年末，工作状态可能也不会很好，此时就可以做一下总结，计划一下来年的工作。 每个小组的测试项目越来越多，可以采用分级管理模式，每个项目设立一位负责人，既提高了大家的责任感，提高了自己的管理能力。同时也让大家从工作中学会了换位思考，体会到做组员和负责人的立场与想法，也分担了组长的工作。","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"软件测试","slug":"技术/软件测试","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/软件测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://sophoraflower.github.io/EverQuest/tags/测试/"}]},{"title":"上海-西塘-绍兴","slug":"上海-西塘-绍兴","date":"2016-08-07T16:00:00.000Z","updated":"2018-01-20T15:21:12.950Z","comments":true,"path":"2016/0808/上海-西塘-绍兴/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0808/上海-西塘-绍兴/","excerpt":"","text":"上海(^)西塘 绍兴","categories":[{"name":"摄影","slug":"摄影","permalink":"https://sophoraflower.github.io/EverQuest/categories/摄影/"}],"tags":[{"name":"摄影","slug":"摄影","permalink":"https://sophoraflower.github.io/EverQuest/tags/摄影/"}]},{"title":"《页面架构》课堂交流问题汇总","slug":"《页面架构》课堂交流问题汇总","date":"2016-06-28T10:21:00.000Z","updated":"2018-01-20T13:34:39.466Z","comments":true,"path":"2016/0628/《页面架构》课堂交流问题汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0628/《页面架构》课堂交流问题汇总/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《页面架构》学习总结 居中布局问题一：水平列表的底部对齐如图所示，一个水平排列的列表，每项高度都未知，但要求底部对齐，有哪些方法可以解决呢？ &emsp;&emsp;&emsp;&emsp; 解决方案： 方法一：子元素设置：display：inline-block + vertical-align:bottom 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; &#125; .child&#123; display:inline-block; vertical-align:bottom; &#125; .child_a&#123; width:150px; height:100%; background:red; &#125; .child_b&#123; width:150px; height:75%; background:green; &#125; .child_c&#123; width:150px; height:50%; background:black; &#125; .child_d&#123; width:150px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法二：position:relative + 子元素：position:absolute + bottom：0 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; position:relative; &#125; .child&#123; position:absolute; bottom:0; &#125; .child_a&#123; width:150px; height:100%; left:15px; background:red; &#125; .child_b&#123; width:150px; left:180px; height:75%; background:green; &#125; .child_c&#123; width:150px; left:345px; height:50%; background:black; &#125; .child_d&#123; width:150px; left:510px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法三：父元素：dispaly:flex + align-items:flex-end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; text-align:center; display:flex; align-items:flex-end; &#125; .child&#123; margin-left:15px; &#125; .child_a&#123; width:150px; height:100%; background:red; &#125; .child_b&#123; width:150px; height:75%; background:green; &#125; .child_c&#123; width:150px; height:50%; background:black; &#125; .child_d&#123; width:150px; height:25%; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 方法四：弹性盒模型 &emsp;&emsp;相关重点文章推荐： &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（一） &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（二） &emsp;&emsp;《CSS3实战》笔记–弹性盒模型（三）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;水平列表的底部对齐&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; height:500px; width:800px; border:1px solid #CCC; display:box; // 设置为盒子显示 display:-moz-box; display:-webkit-box; orient:horizontal; // 定义父元素内子元素的流动 -mozbox-orient:horizontal; -webkit-orient:horizontal; box-align:end; -moz-box-align:end; -webkit-box-align:end; &#125; .child&#123; &#125; .child_a&#123; width:200px; height:500px; background:red; &#125; .child_b&#123; background:green; width:200px; height:350px; &#125; .child_c&#123; background:black; height:250px; width:200px; &#125; .child_d&#123; width:200px; height:150px; background:yellow; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child child_a\"&gt;我是最左边的&lt;/div&gt; &lt;div class=\"child child_b\"&gt;我是老二，嘿嘿&lt;/div&gt; &lt;div class=\"child child_c\"&gt;我是倒数第二！能看到我吗？&lt;/div&gt; &lt;div class=\"child child_d\"&gt;我是倒数第一吆~&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 问题二：实现一个幻灯布局&emsp;&emsp;一个幻灯片效果如图： &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;已知结构如下： 12345&lt;div class=\"slide\"&gt; &lt;!-- 图片省略 --&gt; &lt;!-- 以下是指示器 --&gt; &lt;div class=\"pointer\"&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;要求如下：幻灯（slide）宽高未知，指示器（pointer）在底部且水平居中，距离底部10px，指示器中的圆直径为10px，个数未知，背景为黑色，间距为5px，请完成CSS。 &emsp;&emsp;解答：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;幻灯图&lt;/title&gt; &lt;style type=\"text/css\"&gt; .slide&#123; width:600px; height:300px; background:#9dc3e6; position:relative; &#125; .pointer&#123; position:absolute; left:50%; transform:translate(-50%); bottom:10px; &#125; .pointer i&#123; display:block; float:left; margin-right:5px; width:10px; height:10px; border-radius:50%; background-color:black; &#125; .pointer i:last-child&#123; margin-right:0; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=\"slide\"&gt; &lt;!-- 图片省略 --&gt; &lt;!-- 以下是指示器 --&gt; &lt;div class=\"pointer\"&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;i&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多列布局问题一：一个全等四宫格的实现&emsp;&emsp;一个未知宽高的容器，要被均分为四个相同大小格子（即四个容器），且格子间有10px间距（即十字型空隙），有哪些方法可以解决呢？ &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;方法一：（效果不好，Firefox浏览器效果基本可以，需要css微调） 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; .parent&#123; border:1px solid #CCC; margin:0 auto; width:420px; height:420px; &#125; .box&#123; background:#009999; height:200px; width:200px; display:inline-block; &#125; .box:nth-child(1)&#123; margin:0 17px 0 0; &#125; .box:nth-child(even)&#123; margin:0 0 0 -2px; &#125; .box:nth-child(3)&#123; margin:17px 17px 0 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &emsp;&emsp;方法二： （display：flex） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; .parent&#123; width:410px; height:410px; border: 1px solid #CCC; display:flex; flex-direction:row; flex-wrap:wrap; justify-content:space-between; &#125; .box&#123; width:200px; height:200px; background:#009999; &#125; .box3&#123; align-self:flex-end; &#125; .box4&#123; align-self:flex-end; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &emsp;&emsp;方法三：box-sizing:border-box; background-clip:content-box; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;一个全等四宫格的实现&lt;/title&gt; &lt;style type=\"text/css\"&gt; html,body&#123;height:100%;&#125; .parent&#123; width:50%; height:50%; border: 1px solid #CCC; &#125; .box&#123; background:#009999; float:left; width:50%; height:50%; box-sizing:border-box; background-clip:content-box; &#125; .box1&#123; padding-right:10px; padding-bottom:10px; &#125; .box2&#123; padding-bottom:10px; &#125; .box3&#123; padding-right:10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"box box1\"&gt;&lt;/div&gt; &lt;div class=\"box box2\"&gt;&lt;/div&gt; &lt;div class=\"box box3\"&gt;&lt;/div&gt; &lt;div class=\"box box4\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 全屏布局问题：已知HTML结构和效果图如下：123&lt;div class=\"a\"&gt; &lt;div class=\"b\"&gt;Hello World&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;假设以上父元素称为A，子元素称为B &emsp;&emsp;&emsp;&emsp; &emsp;&emsp;请写出CSS以实现以下弹窗需求：弹窗（B）固定在浏览器窗口中间，弹窗背景色为白色，弹窗宽高由其内容决定，弹窗四周为黑色半透明（0.5透明度）遮罩。 &emsp;&emsp;HTML代码： 123456789&lt;div class=\"a\"&gt; &lt;div class=\"b\"&gt; &lt;!-- 测试弹窗高度由内容决定 &lt;p&gt;Hello World&lt;/p&gt; &lt;p&gt;Hello World&lt;/p&gt; --&gt; Hello World &lt;/div&gt;&lt;/div&gt; &emsp;&emsp;CSS代码： 12345678910111213141516.a &#123; position: fixed; height: 100%; width: 100%; background-color: #000; opacity: 0.5; filter: alpha(opacity=50); &#125; .b &#123; background-color: #fff; display: inline-block; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125; 响应式高清屏的背景图片适配&emsp;&emsp;当我们把一个图标做成CSS中的背景图，在视网膜屏上预览时会发现图标是模糊的，所以我们会同时准备一个2倍大小的图标给高清屏，那么问题来了，怎么实现在普通屏下是普通背景图，而在高清屏下是用的高清图呢？ &emsp;&emsp;解答： 方法一：&lt;img&gt; 标签引用的图片 &emsp;&emsp;通过js做自动适配 1234567891011&lt;img class=\"photo\" src=\"./photo.jpg\" style=\"width:300px;height:200px;\" /&gt; &lt;script type=\"text/javascript\"&gt;$(document).ready(function () &#123; if (window.devicePixelRatio &gt; 1) &#123; var images = $(\"img.photo\"); images.each(function(i) &#123; var x1 = $(this).attr('src'); var x2 = x1.replace(/(.*)(\\.\\w+)/, \"$1@2x$2\"); $(this).attr('src', x2); &#125;); &#125;&#125;);&lt;/script&gt; &emsp;&emsp;Retina.js 提供了更加完善的解决方案，自动匹配屏幕分辨率的同时，还可以检测服务器上是否存有当前图片的 @2X 版本，以决定是否替换。 &emsp;&emsp;优点： 操作简单 普通屏幕下不会加载 @2X 的大尺寸图片，节约带宽 &emsp;&emsp;缺点： Retina 屏幕下，标准图片和高清的图片都会被加载 图片在显示过程中会被重绘 有些老版本浏览器下存在兼容问题（一些老版本浏览器如 IE6、7 会显示得非常失真） &emsp;&emsp;方法二：CSS的media标签 12345678@media only screen and (-webkit-min-device-pixel-ratio: 1.5), only screen and (min--moz-device-pixel-ratio: 1.5), /* 注意这里的写法比较特殊 */ only screen and (-o-min-device-pixel-ratio: 3/2), only screen and (min-device-pixel-ratio: 1.5) &#123; #logo &#123; background-image: url(./logo@2x.png); background-size: 100px auto; &#125;&#125; &emsp;&emsp;优点： 只会加载匹配当前设备的最适图片 跨浏览器兼容 &emsp;&emsp;缺点： 如果背景图片很多的话，需要编写非常冗长的代码 &emsp;&emsp;方法三：css的image-set方法1background-image: -webkit-image-set(url(./logo.png) 1x, url(./logo@2x.png) 2x); &emsp;&emsp;优点：css中编写，图片集中，代码量少&emsp;&emsp;缺点：存在兼容性问题，仅支持background-image属性，而不能使用在“”标签中，是css4的草案。 问题：完成响应式布局的实现&emsp;&emsp;已知一个自适应布局的HTML结构如下：1234&lt;div class=\"parent\"&gt; &lt;div class=\"side\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/div&gt; &emsp;&emsp;请完成以下响应式要求： 默认情况，PC电脑（假设视窗都大于等于1000px）访问：两列布局，.parent宽960px且水平居中，左列.side宽300px，右列.main宽650px，列间距10px。 当用平板（假设视窗都大于400px且小于1000px）访问：两列布局，.parent宽度撑满，右列.main自适应剩余宽度，两列间距仍旧为10px。 当用手机（假设视窗都小于等于400px）访问：上下两行布局，.parent宽度撑满，.side和.main宽度也撑满，行间距为10px。 &emsp;&emsp;解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;完成响应式布局的实现&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=no\"/&gt; &lt;style type=\"text/css\"&gt; html, body &#123; margin: 0; padding: 0; height: 100%; background-color: lightgray; &#125; /* 默认情况：两列布局，.parent宽960px且水平居中，左列.side宽300px，右列.main宽650px，列间距10px*/ .parent &#123; width: 960px; height: 100%; margin: 0 auto; &#125; .side &#123; float: left; background-color: lightblue; width: 300px; height: 100%; &#125; .main &#123; background-color: red; width: 650px; margin-left: 310px; height: 100%; &#125; /* 当用平板（假设视窗都大于400px且小于1000px）访问：两列布局，.parent宽度撑满，右列.main自适应剩余宽度，两列间距仍旧为10px。 */ @media screen and (min-width: 400px) and (max-width: 1000px) &#123; .parent &#123; width: 100%; &#125; .main &#123; width: auto; &#125; &#125; /* 当用手机（假设视窗都小于等于400px）访问：上下两行布局，.parent宽度撑满，.side和.main宽度也撑满，行间距为10px。 */ @media screen and (max-width: 400px) &#123; .parent &#123; width: 100%; &#125; .side &#123; width: 100%; float: none; &#125; .main &#123; width: 100%; margin-left: 0; margin-top: 10px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"side\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 页面优化问题：页面优化的方法 减少请求。 减少文件大小。 提升页面性能。 提升可读性，维护性。 减少请求 图片合并（62%的内容是图片） &emsp; &emsp; 1）选择合适的图片格式（PNG，JPG）。 &emsp; &emsp; 2）压缩图片（imageOptim,imageAlpha,JPEGmini） CSS合并 &emsp; &emsp; 1）多个CSS文件合并为一个。 &emsp; &emsp; 2）少量CSS样式内联 &emsp; &emsp; 3）避免使用import（同步的单线程请求）的方式引入CSS文件。 &emsp; &emsp; 4）值缩写。（margin,padding,border,border-radius,font,background） &emsp; &emsp; 5）省略值为0的单位。（0px,0%,0.5） &emsp; &emsp; 6）颜色值最短表示（red,rgb(255,255,0),rgba,#333） &emsp; &emsp;7）选择器合并(.m-logo,.m-var) &emsp; &emsp; 8）文件压缩（上线前，去空格） 页面性能优化 加载顺序（CSS放上面，JS放下面） 减少标签数量 选择器长度 耗性能属性（expression） 图片设置宽高 所有表现用CSS实现 可读性，可维护性 规范 语义化 尽量避免HACK 模块化 注释 问题：代码优化&emsp;&emsp;请对以下CSS进行优化:123456789101112131415161718192021222324252627282930h1&#123;font-weight: bold;&#125;h2&#123;font-weight: bold;&#125;h3&#123;font-weight: bold;width:100px;&#125;.g-bd&#123; border-top: 1px solid #000; border-right: 1px solid #f00; border-bottom: 1px solid #f00; border-left: 1px solid #000; color: #bbff22;&#125;.m-tab&#123; margin-top: 10px; margin-right: 10px; margin-bottom: 20px; margin-left: 10px; color: rgb(255,0,0);&#125;.m-tab li a&#123; display: block; padding: 0px 10px; font-family: \"Microsoft YaHei\", simsun; font-size: 20px; line-height: 1.5;&#125;.m-side&#123; width: 200px; background-image: url(bg.png); background-repeat: repeat-y; background-color: #ccc;&#125; &emsp;&emsp;解答： 123456h1,h2,h3&#123;font-weight: bold;&#125;h3&#123;width:100px;&#125;.g-bd&#123;border: 1px solid #000;border-color: #000 #f00 #f00 #000;color: #bf2;&#125;.m-tab&#123;margin:10px 10px 20px;color: red;&#125;.m-tab li a&#123;display: block;padding: 0 10px;font: 20px/1.5 \"Microsoft YaHei\", simsun;&#125;.m-side&#123;width: 200px;background: #ccc url(bg.png) repeat-y;&#125; 规范&emsp;&emsp;####问题：制订一份CSS规范 &emsp;&emsp;解答： 一、文件规范 1.文件按照通用类和业务类进行归档 2.文件使用外联引入，其他一些样式使用内联引入 3.文件名采用小写字母，可适当加中划线，然后使用数字来表示版本 4.编码采用utf-8格式 二、注释规范 1.块状注释：统一缩进，在被注释对象之上 2.单行注释：文字两端空格，在被注释对象之上 3.行内注释：文字两端空格，分号之后 三、命名规范 1.采用分类命名，布局类以g-开头，实际内容以m-开头 2.命名具有可读性且长度适中，适当缩写 3.语义化命名方式 四、书写规范 1.多行书写，便于阅读 2.默认缩进为两个空格 3.css规则内一个空格 4.需要保留最后一个属性值的分号 5.属性书写顺序按照：位置属性——自身盒模型相关属性——显示属性 的顺序来书写 6.尽量少使用Hack，ie6采用_开头，ie67采用*开头，先写ie67的，再写ie6的 7.color命名采用十六进制，且尽量缩写 8.url()文件格式不加引号 五、其他规范 1.&lt;!DOCTYPE html&gt; 顶格开始文档声明 2.闭合标签均闭合，自闭合标签也需要闭合 3.属性采用单引号，readonly、checked等属性可以直接写，不用=&quot;&quot; 4.采用缩进体现层级，正确嵌套，但不宜太深，影响性能 5.注释：&lt;!-- A --&gt; xxx &lt;!-- /A --&gt; 6.标签属性均小写 7.文件语义化命名，且不能过长 8.保留源文件 9.使用sprite技术来合并图片 10.图片按照模块、业务、页面来划分 模块化问题：页面模块化优点&emsp;&emsp;解答： 利于多人协同开发 便于扩展和重用 可读性，可维护性好 灵活，快速，高效.不会出现样式污染","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"Web","slug":"技术/Web","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/Web/"}],"tags":[]},{"title":"《DOM编程艺术》课堂交流问题汇总之进阶篇","slug":"《DOM编程艺术》课堂交流问题汇总之进阶篇","date":"2016-06-08T06:26:00.000Z","updated":"2018-01-20T13:28:32.491Z","comments":true,"path":"2016/0608/《DOM编程艺术》课堂交流问题汇总之进阶篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0608/《DOM编程艺术》课堂交流问题汇总之进阶篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《DOM编程艺术》学习总结 样式操作相关笔记推荐：前端微笔记-样式操作 问题一：如何实现浏览器兼容版的window.getComputedStyle window.getComputedStyle能够获取元素的实际样式，但是低版本的ie8及以下不支持，如何在低版本的ie上兼容类似的功能。 解答： 1234567function getComputedStyle(element)&#123; if(window.getComputedStyle)&#123; return window.getComputedStyle(element); &#125; else &#123; return element.currentStyle; &#125; 问题二：实现getStyle函数 getStyle函数用于获取元素的实际样式，语法如下： 1var cssPropertyValue = getStyle (element, cssPropertyName)； 使用示例如下： 1getStyle(element, \"color\") 返回element元素的显示颜色，如：\"rgb(0, 0, 0)\" 1getStyle(element, \"line-height\") 返回element元素的实际行高，如：\"30px\" 请实现getStyle函数，要求浏览器兼容。 解答： 1234567function getStyle(element,cssPropertyName)&#123; if(!window.getComputedStyle)&#123; return element.currentStyle[cssPropertyName]; &#125;else&#123; return getComputedStyle(element)[cssPropertyName]; &#125; &#125; 数据通信相关笔记推荐：前端微笔记-《DOM编程艺术》-数据通信 ####问题一：Ajax请求GET方法的封装 方法 1get(url, options, callback) 参数 123url &#123;String&#125; 请求资源的urloptions &#123;Object&#125; 请求的查询参数callback &#123;Function&#125; 请求的回调函数，接收XMLHttpRequest对象的responseText属性作为参数 返回 1void 举例 123get(‘/information’, &#123;name: ‘netease’, age: 18&#125;, function (data) &#123; console.log(data);&#125;); 描述 1方法get(url, options, callback) 是对Ajax请求GET方法的封装。请写出get方法的实现代码。 解答： 123456789101112131415161718192021222324252627282930313233343536function get(url, options, callback) &#123; var xhr = new XMLHttpRequest(); //创建XHR对象 // 处理返回数据 xhr.onreadystatechange = function(callback) &#123; if (xhr.readyState == 4) &#123; //浏览器结束请求 if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status == 304) &#123; //status为200-300表示success，304为读取缓存 callback(xhr.responseText); //执行返回的html、xml &#125; else &#123; alert('Requeset was unsuccessful: ' + xhr.status); &#125; &#125; &#125; // 请求参数序列化，把对象转换为例如'name1=value1&amp;name2=value2'的格式 function serialize(data) &#123; if (!data) &#123;return '';&#125; var pairs = []; for(var name in data)&#123; if (!data.hasOwnProperty(name)) &#123;continue;&#125; //判断对象自身是否有name属性 if (typeof data[name] === 'function') &#123;continue;&#125; //如果对象的值是一个函数，忽略 var value = data[name].toString(); name = encodeURIComponent(name); //把字符串作为URI 组件进行编码。将转义用于分隔 URI 各个部分的标点符号 value = encodeURIComponent(value); pairs.push(name + '=' + value); &#125; return pairs.join('&amp;'); &#125; xhr.open('get',URL,true); //url+查询参数序列号结果 //放在open后执行，表示文本内容的编码方式是URL编码，即除了标准字符外，每字节以双字节16进制前加个“%”表示 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(null); &#125; // test get('/information', &#123;name: 'netease', age: 18&#125;, function (data) &#123; console.log(data); &#125;); 问题二：Ajax请求POST方法的封装 post函数是对Ajax的POST请求的封装，语法如下：1post(url, options, callback) 没有返回值，参数说明如下：123url：请求资源的url，String类型options：请求的查询参数，Object类型callback：回调函数，接收XMLHttpRequest对象的responseText属性作为参数，Function类型 使用示例如下：123post('/addUser', &#123;name: 'jerry', age: 1&#125;, function(data) &#123; // 处理返回数据 &#125;); 请写出post函数的实现代码，要求浏览器兼容。 解答： 12345678910111213141516171819202122232425262728293031323334353637383940function PostAjax(url, options, callback)&#123; var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function()&#123; if(xhr.readyState==4)&#123; if((xhr.status&gt;=200&amp;&amp;xhr.status&lt;300)||xhr.status==304)&#123; callback(xhr.responseText,options); &#125;else&#123; alert(\"Request was unsuccessful:\"+xhr.status); &#125; &#125; &#125; xhr.open(\"post\",url+\"?\"+serialize(options),true); xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded'); xhr.send(null);&#125; var url=\"http://study.163.com/webDev/hotcouresByCategory.htm\"; PostAjax(url,&#123;\"id\":1002963026&#125;,function (data,options) &#123; var ObjData=JSON.parse(data); for(key in ObjData)&#123; if(ObjData[key][\"id\"]==options.id)&#123; console.log(ObjData[key]); &#125; &#125; &#125;); function serialize(data)&#123; if(!data) return \"\"; var pairs=[]; for(var name in data)&#123; if(!data.hasOwnProperty(name)) continue; if(typeof data[name]===\"function\") continue; var value=data[name].toString(); name=encodeURIComponent(value); value=encodeURIComponent(value); pairs.push(name+\"=\"+value); &#125; return pairs.join(\"&amp;\");&#125; 数据存储问题：cookie的作用和弊端 用cookie作为浏览器端的存储有哪些作用？有哪些弊端，是否有替代的解决办法？ 解答： 作用： 可以在客户端上保存用户数据，起到简单的缓存和用户身份识别等作用。 保存用户的登陆状态，用户进行登陆，成功登陆后，服务器生成特定的cookie返回给客户端，客户端下次访问该域名下的任何页面，将该cookie的信息发送给服务器，服务器经过检验，来判断用户是否登陆。 记录用户的行为。 弊端： 增加流量消耗，因为每次请求都会带上cookie信息 安全性隐患，cookie使用明文传输 大小限制：最大容量在4KB左右","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《产品前端架构》课堂交流问题汇总","slug":"《产品前端架构》课堂交流问题汇总","date":"2016-06-05T04:36:00.000Z","updated":"2018-01-20T13:30:44.264Z","comments":true,"path":"2016/0605/《产品前端架构》课堂交流问题汇总/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0605/《产品前端架构》课堂交流问题汇总/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《产品前端架构》学习总结 版本管理问题一：分布式版本控制(DVCS) 对比集中式版本控制系统(CVCS)&emsp;&emsp;由于Git的持续火热， 对于DVCS与CVCS的争论和对比越来越多了， 似乎很多文章都倾向于这个观点： &quot; Git这种DVCS 要比SVN这些DVCS要优越&quot; &emsp;&emsp;实际情况真的是这样吗？ 现在请同学们各抒己见， 以各个方面来分析下CVCS与 DVCS之间的优缺点. 回答： &emsp;&emsp;分布式版本控制 (DVCS) :一种不需要中心服务器的管理文件版本的方法，但是它也可以使用中心服务器。更改可以被合并到 DVCS 的任何其他用户的系统中，因此可以实现非常灵活的工作流。 主要优点： 版本控制更加灵活，因为它除了支持传统的（集中式）工作流，还支持其他各种工作流； 比集中式服务器快得多，因为大多数操作在客户机本地进行，而不需要网络操作。 &emsp;&emsp;集中式版本控制（ CVCS）：这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 优点与缺点： 每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。 最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 DVCS 和集中式版本控制系统的主要差异： &emsp;&emsp;在 DVCS 和集中式版本控制系统之间有三个关键差异： DVCS 通过本地提交支持离线工作，这是由 DVCS 的操作方式决定的。这与集中式版本控制完全不同，集中式版本控制要求通过到中心服务器的连接执行所有操作。这种灵活性让开发人员在飞机上也能够像在办公室中一样轻松地工作，可以一次又一次地进行提交。 DVCS 比集中式系统更灵活，因为 DVCS 支持许多不同类型的工作流，从传统的集中式工作流到纯粹的特殊工作流，再到特殊工作流和集中式工作流的组合。这种灵活性允许通过电子邮件、对等网络和开发团队喜欢的任何方式进行开发。 DVCS 比集中式版本控制系统快得多，因为大多数操作在客户机上进行，速度非常快。另外，在需要进行推（push）操作（与另一个节点通信）时，速度也更快，因为两个客户机机器上都有完整的元数据。速度差异相当显著，根据使用本地存储库还是网络存储库，DVCS 比Subversion 快大约 3-10 倍。 观点分析：“Git这种DVCS 要比SVN这些DVCS要优越” SVN属于集中化的版本控制系统，SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。SVN大都采用图形界面操作，直观，上手快。 Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。不支持中文，图形界面支持差，使用难度大。不易推广。 SVN更适用于项目管理， Git仅适用于代码管理。 一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物， 包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效。而很容易的实现了对本地代码修改的记录，而这整个过程中，根本没出现服务器。 其他详细内容参考下面推荐文章。 Git和SVN之间的五个基本区别； SVN和Git比较，哪个好用，适用？ 版本控制：SVN和GIT的一些使用感受 关于本地、集中式、分布式三种版本控制系统 分布式版本控制系统入门 问题二：在命令介绍中 多次提到的 – 是用来做什么的？在课程中， 可以发现讲师多次在命令中使用到了 – 符号， 比如 git checkout -- &lt;filename&gt; 事实上 很多时候 你使用 git checkout 也不会有问题。 那么问题来了， – 到底是用来做什么的呢？ 回答：（这个是参考别人的） --代表后面的参数是命令，如果没有--，一般指分支或者路径。 1主要是用来区分文件目录和命令的关系。 1234567891011121314151617题目中“--”后面的表示把后面连接的参数当做文件名，不管它长什么样子。它是unix的命令行规范。通常，我们使用“--”去区分后面的是一个命令还是一个参数。比如下面例子：rm -f # does nothingrm -- -f # deletes a file named &quot;-f&quot;一般我们通过使用它来区分文件名和命令参数，如果一个文件名刚好和我们常用的命令冲突了，--就可以很好的解决这个问题。通常都会加上“--”来区分使用。具体规范和标准可以看unix命令行参数语法规范标准，IEEE Std 1003.1, 2013 Edition标准Guideline 10:The first -- argument that is not an option-argument should be accepted as a delimiter indicating the end of options. Any following arguments should be treated as operands, even if they begin with the &apos;-&apos; character. ####问题三：某文件在暂存区与工作目录的内容不一致时， 使用git checkout HEAD – 将导致什么结果？ 解答： 结论：git checkout HEAD – 将内容从上次提交复制到工作目录。当某文件在暂存区与工作目录的内容不一致时， 使用git checkout HEAD – 将导致工作目录被上次提交的覆盖，这时候暂存区也就没有修改了，clean掉了。其实就是本地和暂存区都被上一次的提交覆盖了。 简单实验了下，测试过程如下： 1、首先新建了一个test.txt文件，文件是空的。这时候我们将test.txt add到暂存区，此时暂存区存在新的文件test.txt。2、将暂存区的修改提交到提交区，这时候暂存区也就没有需要提交的东西了。3、本地修改test.txt文件，随便输入一些字符。此时test.txt文件大小为1KB4、此时，查看暂存区，发现暂存区存在修改文件，test.txt，这时候，test.txt文件在暂存区与工作目录的内容不一致5、执行git checkout HEAD – ，发现暂存区不存在修改文件，查看本地目录，test.txt文件已经为空，被上次提交区的空test.txt覆盖此时test.txt文件为空，0KB 问题四：为什么大部分情况下，git fetch 要优于直接使用 git pull?不难发现， 课程中对于可能常用的 git pull 命令着墨不多. 而把大量的时间放在了 git fetch + git merge 的工作原理上。 同学可以总结下，为何使用git fetch来分步骤处理 要优于直接使用git pull？ 回答： &emsp;&emsp;git pull的问题是它把过程的细节都隐藏了起来，以至于你不用去了解git中各种类型分支的区别和使用方法。当然，多数时候这是没问题的，但一旦代码有问题，你很难找到出错的地方。 &emsp;&emsp;将下载（fetch）和合并（merge）放到一个命令里的另外一个弊端是，你的本地工作目录在未经确认的情况下就会被远程分支更新。当然，除非你关闭所有的安全选项，否则git pull在你本地工作目录还不至于造成不可挽回的损失，但很多时候我们宁愿做的慢一些，也不愿意返工重来。 &emsp;&emsp;前面那些行显示出“git fetch”命令会将哪些文件下载到本地，这些文件一旦下载到本地之后，就可以在本地进行任意操作了。 &emsp;&emsp;“git fetch”命令执行完毕之后，还不会立即将下载的文件合并到你当前工作目录里，这就给你了一个选择下一步操作的机会，要是想将从远程分支下载的文件更新到你的工作目录里，你需要执行一个“合并（merge）”操作。 &emsp;&emsp;单独进行下载和合并是一个好的做法，你可以先看看下载的是什么，然后再决定是否和本地代码合并。而且分开来做，可以清晰的区别开本地分支和远程分支，方便选择使用。 文章推荐：Git 少用 Pull 多用 Fetch 和 Merge 技术选型问题一：市面上这么多种模块系统， 它们之间可以相互转换吗&emsp;&emsp;AMD、COMMONJS、CMD、UMD、ES6 Module、IIFE… 这么多的模块写法， 一旦你选择了一种模块写法，那它在另一个系统中就可能无法运行了。 值得庆幸的是，现在越来越多的工具可以帮助我们将js从一种模块写法转换为另一种写法， 你能帮助同学们列举出一个或多个转换工具吗？ 回答： 1、Browserify 12兼容 Node 模块引用语法和 Node 模块化文件加载方案, 浏览器端运行前需要完成代码的合并, 并配合 SourceMap 进行调试. 2、Webpack1它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理 3、Component1是一个对客户端 JavaScript 包进行管理的工具，用于更好的构建 Web 应用，编写模块化 commonjs 组件 4 rderjs1一个开源的 JS 按需、异步加载工具，同时也是 JS 模块化管理工具。 5 systemjs1一个最小系统加载工具。 问题二：关于通信解决方案 xhr 与 socket的取舍&emsp;&emsp;视频里介绍了一个双向实时通信解决方案socket.io。你能说出一些这种解决方案的适合场景吗？&emsp;&emsp;实时上在规范中，还有一个Server-Send-Event的规范， 可以帮助我们实现服务器端-&gt;浏览器端的反向消息推送，同学们可以下去学习一下。 回答： &emsp;&emsp;Socket.IO设计的目标是构建能够在不同浏览器和移动设备上良好运行的实时应用，如实时分析系统、二进制流数据处理应用、在线聊天室、在线客服系 统、评论系统、WebIM等。目前，Socket.IO已经支持主流PC浏览器(如IE、Safari、Chrome、Firefox、Opera等)和 移动平台上的浏览器（iOS平台下的Safari、Android平台下的基于Webkit的浏览器等）。 &emsp;&emsp;参考自《Socket.IO：支持WebSocket协议、用于实时通信和跨平台的框架》 问题三：大型的组件库为什么都用到了预处理？&emsp;&emsp;事实上处理bootstrap、foundation. 还有一些其它类似规模的组件库， 它们或许在设计和css构建上理念上有部分区别， 它们都非常一致的使用了css预处理器来管理css文件， 你能说出这么做的好处吗？ 回答： 让 CSS 更见简洁，适应性更强，代码更直观，节省了大量的重复工作和痛苦的代码编辑； 参考自：《为您详细比较三个 CSS 预处理器（框架）：Sass、LESS 和 Stylus》 缓解多浏览器兼容造成的冗余； 参考自《为什么要使用CSS预处理器？》 提供CSS缺失的样式层复用机制，提高CSS代码的可维护性 开发实践问题一：采用文档形式的规范输出有哪些弊端？&emsp;&emsp;采用文档形式的规范输出有哪些弊端？可以从协作、后续对规范的重用等方面进行讨论 回答： 假设题目里面说的是开发规范。文档类型的规范的效力依赖于开发人员的对规范的理解，和遵守规范的程度，需要再有一层QA进行保障。还有就是文档规范需要根据技术和业务的发展定期更新，更新后还要宣贯。否则可能就过时或者成为纸上的规范。尽量还是能通过工具、统一的框架、模块来规范输出。 从协助上来说：没有统一规范的管理，可能导致更新不及时，协助起来大家阅读时存在一些问题等。从后续重用性来说：文档形式的规范输出难以保证完全的统一和规范性，后续的修改和重用还需要先了解前面的具体规范再做进一步修改，学习成本更大，且容易导致问题。 问题二：实际项目中对系统进行分解的难点有哪些？&emsp;&emsp;实际项目中对系统进行分解的难点有哪些？ 回答：仁智见仁，智者见智。没有实际经验回答个毛！！ 问题三：如何根据交互提取通用组件&emsp;&emsp;如何根据交互提取通用组件？交互稿中哪些可以作为通用的组件进行封装？ 回答： &emsp;&emsp;视觉说明中包含各个情况下用户界面的显示样式，其定义了交互稿中的所有效果。之后则需要从中提取出通用组件，其中包括： 通用原件（Logo，提示，输入框，图标，按钮等） 通用列表（以网易云音乐为例，一般歌单，排行榜，收藏列表，歌手等） 复合组件（留言板类，评论控件） 浮层弹出 问题四：项目发布时需要做哪些优化？回答: 图片的优化，压缩大小 CDN的配置 代码的压缩和合并 问题五：实际项目中发布工具的哪些功能是你比较关注的？回答：仁智见仁，智者见智。没有实际经验回答个毛！！","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"Web","slug":"技术/Web","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/Web/"}],"tags":[]},{"title":"《DOM编程艺术》课堂交流问题汇总之基础篇","slug":"《DOM编程艺术》课堂交流问题汇总之基础篇","date":"2016-05-24T02:53:00.000Z","updated":"2018-01-20T13:28:37.861Z","comments":true,"path":"2016/0524/《DOM编程艺术》课堂交流问题汇总之基础篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0524/《DOM编程艺术》课堂交流问题汇总之基础篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《DOM编程艺术》学习总结 问题一：实现浏览器兼容版的element.childrenelement.children能够获取元素的元素子节点，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。 分析解答： 思路： 写一个函数getElementChild(element),传入一个父节点element. 判断DOM中element对象的children属性是否存在，存在则直接返回element.children,不存在则执行兼容代码. 兼容代码思路： 创建一个数组elementArr以便返回最终 [符合要求] 的子节点集合。 调用element对象的childNodes属性，以获取其子节点集合。 遍历子节点集合，对每一个子节点进行判断，如果节点类型为1（即节点类型为元素节点）,则添加到elementArr返回数组中。 返回数组elementArr 解决代码： 123456789101112131415// nodeType=1 元素节点 nodeType=2 属性节点 nodeType=3 文本节点function getElementChild(element)&#123; if (!element.children) &#123; //如果没有children方法 var result_elementchild = [], //新的元素子节点数组 nodelist = element.childNodes; //获取所有子节点 for (var i = 0; i &lt; nodelist.length; i++) &#123; if(nodelist[i].nodeType == 1)&#123; //判断节点是否为元素节点 result_elementchild.push(nodelist[i]); &#125; &#125; return result_elementchild; &#125; else &#123; return element.children; &#125;&#125; 问题二：实现浏览器兼容版的element.datasetelement.dataset能够获取元素的自定义属性，但是低版本的ie不支持，如何在低版本的ie上兼容类似的功能。 相关文章推荐： HTML data属性简介以及低版本浏览器兼容算法 （很经典，不错的文章） HTML5自定义属性对象Dataset简介 分析解答： 思路： 找到元素中以data-开头的属性名，取到其名称。 根据dataset的驼峰命名，将data-后面的名称以驼峰命名的方式得到对应的ID名称。 构建ID名称和属性名称的键值对。 使用var attribute = element.getAttribute(attributeName)方法，从键值对中找到ID对应的属性名作为attributeName得到其对应的属性值，然后赋值给对应的ID元素。 解答： 1234567891011121314151617181920212223242526272829303132333435363738394041function $(id)&#123; return document.getElementById(id); &#125; //正则表达式变换首字母大写 function replaceReg(str)&#123; var reg = /\\b(\\w)|\\s(\\w)/g; str = str.toLowerCase(); return str.replace(reg,function(m)&#123;return m.toUpperCase()&#125;) &#125; //带兼容的函数 function get_dataset(ele)&#123; if(ele.dataset) return ele.dataset; else&#123; //一下是兼容代码 var dataset = &#123;&#125;; var ele_split = ele.outerHTML.split(\" \"); for(var i = 0,element; i &lt; ele_split.length; i++) &#123; element = ele_split[i]; if (element.substring(0,4) == \"data\") &#123; if (element.indexOf(\"&gt;\") != -1) &#123; element = element.split(\"&gt;\")[0]; &#125;; ele_key=element.split(\"=\")[0].slice(5); ele_value=element.split(\"=\")[1].slice(1,-1); if(ele_key.indexOf(\"-\") == -1)&#123; dataset[ele_key] = ele_value; &#125;else&#123; ele_keys=ele_key.split(\"-\"); ele_key=ele_keys[0]; for(i=1;i&lt;ele_keys.length;i++)&#123; ele_key+=replaceReg(ele_keys[i]); &#125; &#125; &#125;; &#125; return dataset; &#125; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《JavaScript程序设计》课堂交流问题汇总之进阶篇","slug":"《JavaScript程序设计》课堂交流区问题汇总之进阶篇","date":"2016-05-18T14:03:00.000Z","updated":"2018-01-20T13:27:22.529Z","comments":true,"path":"2016/0518/《JavaScript程序设计》课堂交流区问题汇总之进阶篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0518/《JavaScript程序设计》课堂交流区问题汇总之进阶篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《JavaScript程序设计》学习总结 问题一：复制对象&emsp;&emsp;通过课程学习我们知道，对象作为引用类型，使用运算符=时，只是复制了对象的地址。 &emsp;&emsp;比如如下代码 123var obj1 = &#123;a:1&#125;;var obj2 = obj1;obj2.a = 2; // 此时obj1.a === &emsp;&emsp;修改对象obj2同时会改变obj1，那么如果我们需要克隆出一个独立但属性、方法完全一样的对象，该如何实现？ &emsp;&emsp;解答： 使用for in 1234567var obj2=new Object(); for(var p in obj) &#123; var name=p;//属性名称 var value=obj[p];//属性对应的值 obj2[name]=obj[p]; &#125; &emsp;&emsp;参考：js中如何复制一个对象并获取其所有属性和属性对应的值 定义一个clone方法来实现 1234567891011function clone(myObj)&#123; if(typeof(myObj) != 'object') return myObj; if(myObj == null) return myObj; var myNewObj = new Object(); for(var i in myObj) myNewObj[i] = clone(myObj[i]); return myNewObj; &#125; 通过object原型扩展实现 1234567891011121314151617181920212223Object.prototype.Clone = function() &#123; var objClone; if ( this.constructor == Object ) objClone = new this.constructor(); else objClone = new this.constructor(this.valueOf()); for ( var key in this ) &#123; if ( objClone[key] != this[key] ) &#123; if ( typeof(this[key]) == 'object' ) &#123; objClone[key] = this[key].Clone(); &#125; else &#123; objClone[key] = this[key]; &#125; &#125; &#125; objClone.toString = this.toString; objClone.valueOf = this.valueOf; return objClone; &#125; &emsp;&emsp;参考：js对象复制 问题二：JS和强类型语言（比如C++）在类型方面的主要区别&emsp;&emsp;解答： &emsp;&emsp;强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 &emsp;&emsp;弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。强类型定义语言在速度上可能略逊色于弱类型定义语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。 &emsp;&emsp;二者的区别，在于计算时是否可以不同类型之间对使用者透明地隐式转换。从使用者的角度来看，如果一个语言可以隐式转换它的所有类型，那么它的变量、表达式等在参与运算时，即使类型不正确，也能通过隐式转换来得到正确地类型，这对使用者而言，就好像所有类型都能进行所有运算一样，所以这样的语言被称作弱类型。 &emsp;&emsp;与此相对，强类型语言的类型之间不一定有隐式转换（比如C++是一门强类型语言，但C++中double和int可以互相转换，但double和任何类型的指针之间 问题三：隐式类型转换场景&emsp;&emsp;解答： 四则运算 &emsp;&emsp;加法运算符+是双目运算符，只要其中一个是String类型，表达式的值便是一个String。 &emsp;&emsp;对于其他的四则运算，只有其中一个是Number类型，表达式的值便是一个Number。 &emsp;&emsp;对于非法字符的情况通常会返回NaN： 1'1' * 'a' // =&gt; NaN，这是因为parseInt(a)值为NaN，1 * NaN 还是 NaN 判断语句 &emsp;&emsp;判断语句中的判断条件需要是Boolean类型，所以条件表达式会被隐式转换为Boolean。 其转换规则同Boolean的构造函数。比如： 12var obj = &#123;&#125;;if(obj)&#123; while(obj);&#125; Native代码调用 &emsp;&emsp;JavaScript宿主环境都会提供大量的对象，它们往往不少通过JavaScript来实现的。 JavaScript给这些函数传入的参数也会进行隐式转换。例如BOM提供的alert方法接受String类型的参数： 1alert(&#123;a: 1&#125;); // =&gt; [object Object] == &emsp;&emsp;JS的非严格匹配时会进行隐式类型转换。 问题四：识别类型方法&emsp;&emsp;解答： typeof : 可以识别除null之外的基本类型及对象类型，不能识别具体对象; 1234567typeof 1;//\"number\"typeof \"1\";//\"string\"typeof &#123;&#125;;//\"object\"typeof [];//\"object\"typeof undefined;//\"undefined\";typeof null;//\"object\"typeof true;//\"boolean\" instanceof : 可以识别Object类型和自定义类型，不能识别基本类型 1234[] instanceof Array;//true(&#123;&#125;) instanceof Object;//true(1) instanceof Object;//false(1) instanceof Number;//false constructor : 识别除null和undefined的内置类型及自定义类型 12(1).constructor===Number;//true\"1\".constructor===String;//true Object.prototype.toString().call(obj) : 可以识别标准类型以及内置对象类型；不能识别自定义对象类型； 12Object.prototype.toString().call(null);//\"[object Null]\"Object.prototype.toString().call(undefined);//\"[object Undefined]\" 组合封装函数 123456789/* * 获取对象构造函数名称 * 视频中关于getConstructorName函数写法存在bug，导致传入 0, false, \"\", NaN 这些值时，得到错误的返回结果。 * 1. 入参obj如果是undefined和null，则返回其自身; * 2. 入参obj如果是其他值，则返回obj.constructor&amp;&amp;obj.constructor.toString().match(/function\\s*([^(]*)/)[1]的结果; */ function getConstructorName(obj)&#123; return (obj===undefined||obj===null)?obj:(obj.constructor&amp;&amp;obj.constructor.toString().match(/function\\s*([^(]*)/)[1]); &#125; 问题五：函数声明和函数表达式定义同一个函数时，执行的是哪个？12345678910111213141516// 以下代码执行时，三次打印分别输出什么？为什么？ function add1(i)&#123; console.log(\"函数声明：\"+(i+1));&#125;add1(1); var add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); &emsp;&emsp;解析：1234567891011121314function add1(i)&#123; console.log(\"函数声明：\"+(i+1));&#125;add1(1); //函数声明：101 因为函数声明会被预置到代码顶部，相同的声明后一个起作用，所以调用的是下页的那个函数声明 var add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); //函数表达式：11 因为函数声明已被同名函数表达式覆盖 function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); //函数表达式：11 因为函数声明已被同名函数表达式覆盖 12345678910111213//预解析如下var add1;function add1(i) &#123; console.log(\"函数声明：\"+(i+100));&#125;add1(1); add1 = function(i)&#123; console.log(\"函数表达式：\"+(i+10));&#125;add1(1); add1(1); &emsp;&emsp;结果如下：123函数声明：101函数表达式：11函数表达式：11 &emsp;&emsp;由于这两点，程序中第一个函数和第三个函数都被提升到了前面，由于函数名相同，后一个覆盖前一个，所以起作用的只有第三个函数，同时第二个以表达式定义的函数的变量名add1也被提升到了程序的前面。 &emsp;&emsp;当第一次调用由于变量add1还没有被定义，函数定义就会覆盖掉变量add1的声明，所以执行结果是调用第三个add函数； 当调用第二个add1时，变量add1已经被定义了，所以覆盖掉了函数声明， 所以之后调用add1执行的都是 以函数表达式定义的函数add1了。 问题六：对象方法中定义的子函数，子函数执行时this指向哪里？三个问题： 以下代码中打印的this是个什么对象？ 这段代码能否实现使myNumber.value加1的功能？ 在不放弃helper函数的前提下，有哪些修改方法可以实现正确的功能？ 1234567891011var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; helper(i); &#125;&#125;myNumber.add(1); &emsp;&emsp;解析： &emsp;&emsp;1. helper中的this指向Window全局变量 &emsp;&emsp;2. 不能。因为 myNumber.value并未增加 方法一：可以把helper调整为方法函数，这样helper就可以正确引用myNumber为this了。 123456789101112 var myNumber = &#123; value:1, helper:function(i) &#123; console.log(this); this.value +=i; &#125;, add: function(i) &#123; this.helper(i); &#125; &#125;myNumber.add(1);console.log(myNumber.value); 方法二：使用闭包 123456789101112var myNumber = &#123; value: 1, add: function(i)&#123; var thisnew = this; // 构建闭包 var helper = function(i)&#123; console.log(thisnew); thisnew.value += i; &#125; helper(i); &#125; &#125; 方法三：使用方法调用模式，因为方法调用模式可以指向调用者 1234567891011121314var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; // 新建一个o对象等于myNumber,将helper方法赋值给该对象， // 然后使用方法调用模式，这样可以让helper中的this指向调用者o,即myNumber var o = myNumber; o.fn = helper; o.fn(i); &#125;&#125; 方法四：使用apply（call）调用模式，将当前helper方法借用给myNumber对象使用，这样this指向的就是myNumber对象 123456789101112var myNumber = &#123; value: 1, add: function(i)&#123; var helper = function(i)&#123; console.log(this); this.value += i; &#125; // myNumber对象借用helper方法，helper中的this将指向myNumber对象 helper.apply(myNumber,[i]); //apply方法 helper.call(myNumber,i); //call方法 &#125;&#125; 问题七：在变量作用域方面，函数声明和函数表达式有什么区别？&emsp;&emsp;解答： &emsp;&emsp;函数声明的执行环境为的上一层执行环境为window，函数表达式的上一层执行环境指向调用它的执行环境。&emsp;&emsp;函数声明会是全局作用域，outer指向window，函数表达式在执行时才会解析，outer指向上一级函数环境。 问题八：闭包的应用场景有哪些？&emsp;&emsp;解答： &emsp;&emsp;闭包的应用场景主要有：保存函数的状态，性能优化和封装； &emsp;&emsp;闭包有优点也有缺点，滥用闭包是非常不可取的， &emsp;&emsp;使用闭包的注意点 &emsp;&emsp;1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 &emsp;&emsp;2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 问题九：原型继承和类继承有什么区别？&emsp;&emsp;解答： &emsp;&emsp;原型继承和类继承是两种认知模式，本质上都是为了抽象（复用代码）。相对于类，原型更初级且更灵活。因此当一个系统内没有太多关联的事物的时候，用原型明显比用类更灵活便捷。 v原型继承的便捷性表现在系统中对象较少的时候，原型继承不需要构造额外的抽象类和接口就可以实现复用。（如系统里只有猫和狗两种动物的话，没必要再为它们构造一个抽象的“动物类”） &emsp;&emsp;原型继承的灵活性还表现在复用模式更加灵活。由于原型和类的模式不一样，所以对复用的判断标准也就不一样，例如把一个红色皮球当做一个太阳的原型，当然是可以的（反过来也行），但显然不能将“恒星类”当做太阳和红球的公共父类（倒是可以用“球体”这个类作为它们的公共父类）。 问题十：实现一个Circle类&emsp;&emsp;编程实现： 123a.创建一个圆（Circle）的类，并定义该类的一个属性（半径）和两个方法（周长和面积），其中圆的半径可以通过构造函数初始化b.创建圆的一个对象，并调用该对象的方法计算圆的周长和面积 &emsp;&emsp;解答： 12345678910111213141516function circle(r)&#123; var cir = new Object(); this.r = r; var perimeter = Math.PI * 2 * this.r; var area = Math.PI * this.r * this.r; cir.run = function()&#123; return \"圆的周长：\"+perimeter+\" \"+\"圆的面积：\"+area; &#125;; return cir;&#125;var cir1 = circle(2);cir1.run();//\"圆的周长：12.566370614359172 圆的面积：12.566370614359172\"var cir2 = circle(3);cir2.run();//\"圆的周长：18.84955592153876 圆的面积：28.274333882308138\" ###问题十一：请使用Js代码写出一个类继承的模型 &emsp;&emsp;请使用Js代码写出一个类继承的模型，需包含以下实现： 123定义父类和子类，并创建父类和子类的属性和方法子类继承父类的属性和方法在创建子类对象时，调用父类构造函数 &emsp;&emsp;解答： 12345678910111213141516171819202122function Car(brand)&#123;//父类构造器 this.brand = brand;//定义父类属性&#125;Car.prototype.getBrand = function()&#123;//定义父类方法 console.log(this.brand);&#125;;function Audi(owner)&#123;//子类构造器 Car.call(this,\"Audi\");//继承并设置父类属性 this.owner = owner;//定义子类属性&#125;Audi.prototype = new Car();//设置子类原型为父类的一个实例，则子类原型的__proto__指向父类原型Audi.prototype.constructor = Audi;//设置子类的constructor为子类构造器Audi.prototype.getBrand = function()&#123; Car.prototype.getBrand.call(this);//继承父类方法&#125;;Audi.prototype.getOwner = function()&#123;//定义子类方法 console.log(this.owner);&#125; var a4 = new Audi(\"jhl\");a4.getBrand();//Audia4.getOwner();//jhl","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"《JavaScript程序设计》课堂交流问题汇总之基础篇","slug":"《JavaScript程序设计》课堂交流区问题汇总之基础篇","date":"2016-05-17T11:19:00.000Z","updated":"2018-01-20T13:27:15.136Z","comments":true,"path":"2016/0517/《JavaScript程序设计》课堂交流区问题汇总之基础篇/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0517/《JavaScript程序设计》课堂交流区问题汇总之基础篇/","excerpt":"","text":"本课程为网易云课堂 - - 前端开发工程师 - - 《JavaScript程序设计》学习总结 问题一：获取随机整数&emsp;&emsp;获取一个大于等于0且小于等于9的随机整数？ 解答： 1234567891011// 方法一：Math.random() -- 返回0和1之间的伪随机数 可能为0，但总是小于1，即取值范围为[0,1)。 Math.floor(Math.random()*10); // 方法二 : 先取0-1的随机数，然后乘以10，获得0-10的随机数，然后向上取整，然后减1，或者乘以9，获得0-9的随机数，然后向上取整 var number=(Math.ceil(Math.random()*10))-1; var number=Math.ceil(Math.random()*9);// 方法三：先取0-1的随机数，然后乘以10，获得0-10的随机数，然后保留0位小数点，获得整数 var number=(Math.random()*10).toFixed(0);//方法四：先取0-1的随机数，然后乘以9.5，获得0-9.5的随机数，然后四舍五入，获得整数 var number=Math.round(Math.random()*9.5);//方法五：先取0-1的随机数，然后乘以10，获得0-10的随机数，然后使用parseInt进行数值转换 var number=parseInt(Math.random()*10); 问题二：字符删除&emsp;&emsp;想要去除一个字符串的第一个字符，有哪些方法可以实现？ 解答： 12345678\"hellomiaomiao\".replace(\"hellomiaomiao\".charAt(0),\"\");\"ellomiaomiao\"//运行结果\"hellomiaomiao\".slice(1);\"ellomiaomiao\"//运行结果\"hellomiaomiao\".substr(1);\"ellomiaomiao\"//运行结果\"hellomiaomiao\".substring(1);\"ellomiaomiao\"//运行结果 问题三：数组求和&emsp;&emsp;对一个数组（每项都是数值）求和，有哪些方法？ 解答： &emsp;&emsp;首先设定一个作为数据源的数组 1var arr = [1, 2, 3, 4, 5, 6,7,8,9,10]; every()方法： 123456789(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); return true;//由于every方法是会在遇到回调函数返回的第一个false时停止遍历所以需要始终返回true &#125;; arr.every(getSum); console.log(\"use every:sum = \" + sum);&#125;)(); some()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.some(getSum); console.log(\"use some:sum = \" + sum);&#125;)(); array.filter()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.filter(getSum); console.log(\"use filter:sum = \" + sum);&#125;)(); array.map()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.map(getSum); console.log(\"use map:sum = \" + sum);&#125;)(); array.froEach()方法： 12345678(function() &#123; var sum = 0; function getSum(item, index, array) &#123; sum += item; console.log(sum); &#125;; arr.forEach(getSum); console.log(\"use forEach:sum = \" + sum);&#125;)(); array.reduce()正向归并方法： 123arr.reduce(function(prevResult, item, index, array) &#123; return prevResult += item; &#125;); array.reduceRight()逆向归并方法： 123arr.reduceRight(function(prevResult, item, index, array) &#123; return prevResult += item; &#125;); for循环方法 123456(function() &#123; for (var i = 0, sum = 0; i &lt; arr.length; i++) &#123; sum += arr[i]; console.log(sum); &#125; console.log(\"use for:sum = \" + sum);&#125;)(); while循环方法 12345678(function()&#123; var i = 0, sum = 0; while(i&lt;arr.length)&#123; sum+=arr[i]; console.log(sum); i++; &#125; console.log(\"use while:sum = \" + sum);&#125;)(); for -in方法 1234567(function() &#123; var sum = 0; for (var index in arr) &#123; sum += arr[index]; console.log(sum); &#125; console.log(\"use for-in:sum = \" + sum);&#125;)(); forEach()方法 1234567var calc = &#123; sum: 0&#125;; function getSum(item, index, array) &#123; this.sum += item; console.log(this.sum); &#125; arr.forEach(getSum,calc); console.log('use forEach and change this:sum=' + calc.sum); join()方法 12eval(arr.join(&quot;+&quot;)); /*这里先将所有数组项通过字符串&quot;+&quot;连为一个字符串&quot;1+2+3+4+5+6&quot;，然后返回的这个字符串传给eval()方法，eval()方法接收了这段字符串后，就直接将这段字符串中的代码放在当前作用域下执行了。*/ 重点相关文章推荐：《数组求和方法比较 》 问题四：量词&emsp;&emsp;正则表达式中，量词的贪婪模式与惰性模式有什么区别？ 解答： &emsp;&emsp;贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。 &emsp;&emsp;贪婪量词：先看整个字符串是否匹配，如果不匹配就把最后一个字符去掉在进行匹配，不匹配继续去掉最后一个字符，指导找到一个匹配或者不剩任何字符才停止。 &emsp;&emsp;惰性量词：先看第一个字符串是否匹配，如果第一个不匹配就在加入第二个字符串依此类推，指导找到一个匹配或者不剩任何字符才停止，贪婪量词与贪婪量词的方法正好相反. &emsp;&emsp;浏览器对量词的支持还不完善，IE和OPERA都不支持量词，MOZILLA把支配量词看作是贪婪的。 &emsp;&emsp;参考文章： 正则表达式之 贪婪与非贪婪模式详解（概述）； JS-正则量词的贪婪、惰性 问题五：JSON.stringify兼容&emsp;&emsp;JSON.stringify函数在ie6/7中不支持，如何兼容？ 解答： jQuery插件支持的转换方式： 1$.parseJSON( jsonstr ); //jQuery.parseJSON(jsonstr),可以将json字符串转换成json对象 Javascript支持的转换方式： 1eval('(' + jsonstr + ')'); //可以将json字符串转换成json对象,注意需要在json字符外包裹一对小括号 &emsp;&emsp;注：ie8(兼容模式),ie7和ie6可以使用eval()将字符串转为JSON对象，但不推荐这些方式，这种方式不安全eval会执行json串中的表达式。 JSON官方的转换方式： &emsp;&emsp;http://www.json.org/提供了一个json.js,这样ie8(兼容模式),ie7和ie6就可以支持JSON对象以及其stringify()和parse()方法；可以在https://github.com/douglascrockford/JSON-js上获取到这个js，一般现在用json2.js。123&lt;!--[if lt IE 9]&gt; &lt;script src=\"json2.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; &emsp;&emsp;这样JSON.stringify 便可以正常使用！ 判断类型加算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function forIn(obj, handler) &#123; for (var i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; handler(i, obj[i]); &#125; &#125;&#125;function each(arr, handler) &#123; for (var i = 0, len = arr.length; i &lt; len; i += 1) &#123; handler(i, arr[i]); &#125;&#125;if (!JSON) &#123; JSON = &#123;&#125;;&#125;if (!JSON.parse) &#123; JSON.parse = function(json) &#123; return eval('1,' + json) &#125;;&#125;if (!JSON.stringify) &#123; (function(JSON) &#123; var arr = '[object Array]', obj = '[object Object]'; JSON.stringify = function(json) &#123; var t = ''; var m = Object.prototype.toString.call(json); if (m == arr) &#123; t = ArrPartten(json); &#125; else if (m == obj) &#123; t = ObjectJson(json); &#125; else &#123; t = json; &#125; return t; &#125; function ObjectParse() &#123; var t = '&#123;'; forIn(json, function(i, ele) &#123; var m = Object.prototype.toString.call(ele); if (m == arr) &#123; t += i + ':' + ArrPartten(ele) + ','; &#125; else if (m == obj) &#123; t += i + ':' + ObjectJson(ele) + ','; &#125; else &#123; t += i + ':' + ele + ','; &#125; &#125;); if (t.length != 1) &#123; t = t.substring(0, t.length - 1); &#125; return t + '&#125;'; &#125; function ArrayParse() &#123; var t = '['; each(json, function(i, ele) &#123; var m = Object.prototype.toString.call(ele); if (m == arr) &#123; t += ArrPartten(ele) + ','; &#125; else if (m == obj) &#123; t += ObjectJson(ele) + ','; &#125; else &#123; t += ele + ','; &#125; &#125;); if (json.length &gt; 0) &#123; t = t.substring(0, t.length - 1); &#125; return t + ']'; &#125; &#125;(JSON));&#125; 判断类型加算法实现（版本二） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950if(!window.JSON)&#123; window.JSON = &#123; parse: function(sJson)&#123; return eval(\"(\" + sJSON + \")\"); &#125;, stringify: function(obj)&#123; var result = \"\"; for(var key in obj)&#123; if(typeof obj[key] == \"string\")&#123; // 如果属性值是String类型，属性值需要加上双引号 result += \"\\\"\" + key + \"\\\":\\\"\" + obj[key] + \"\\\",\"; &#125;else if(obj[key] instanceof RegExp)&#123; // 如果属性是正则表达式，属性值只保留一对空大括号&#123;&#125; result += \"\\\"\" + key + \"\\\":&#123;&#125;,\"; &#125;else if(typeof obj[key] == \"undefined\" || obj[key] instanceof Function)&#123; // 如果属性值是undefined, 该属性被忽略。忽略方法。 &#125;else if(obj[key] instanceof Array)&#123; // 如果属性值是数组 result += \"\\\"\" + key + \"\\\":[\"; var arr = obj[key]; for(var item in arr)&#123; if(typeof arr[item] == \"string\")&#123; // 如果数组项是String类型，需要加上双引号 result += \"\\\"\" + arr[item] + \"\\\",\"; &#125;else if(arr[item] instanceof RegExp)&#123; // 如果属数组项是正则表达式，只保留一对空大括号&#123;&#125; result += \"&#123;&#125;,\"; &#125;else if(typeof arr[item] == \"undefined\" || arr[item] instanceof Function)&#123; // 如果数组项是undefined, 则显示null。如果是函数，则显示null?。 result += null +\",\"; &#125;else if(arr[item] instanceof Object)&#123; //如果数组项是对象(非正则，非函数，非null)，调用本函数处理 result += this.stringify(arr[item]) +\",\"; &#125;else&#123; result += arr[item] + \",\"; &#125; &#125; result = result.slice(0,-1)+\"],\" &#125;else if(obj[key] instanceof Object)&#123; // 如果属性值是对象(非null，非函数，非正则)，调用本函数处理 result += \"\\\"\" + key + \"\\\":\" + this.stringify(obj[key]) + \",\"; &#125;else&#123; result += \"\\\"\" + key + \"\\\":\" + obj[key] + \",\"; &#125; &#125; // 去除最后一个逗号,两边加&#123;&#125; return \"&#123;\" + result.slice(0,-1) + \"&#125;\"; &#125; &#125;;","categories":[{"name":"技术","slug":"技术","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/"},{"name":"JavaScript","slug":"技术/JavaScript","permalink":"https://sophoraflower.github.io/EverQuest/categories/技术/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://sophoraflower.github.io/EverQuest/tags/javascript/"}]},{"title":"西湖春游","slug":"西湖春游","date":"2016-03-22T04:16:00.000Z","updated":"2018-01-20T13:33:46.216Z","comments":true,"path":"2016/0322/西湖春游/","link":"","permalink":"https://sophoraflower.github.io/EverQuest/2016/0322/西湖春游/","excerpt":"","text":"&emsp;&emsp;3月19日，傍晚的时候，和鑫去西湖逛了会，像是去断桥看水墨画展览，三月的西湖，却没能够领会。断桥，白堤，去的时候，都不一样，不一样的景，不一样的水，不同的行人。想起第一次来西湖，大年初一，人一点都不少，同行一块四个人，真是时不同，景不同，人更不同！ &emsp;&emsp;那会的心除了被西湖之景所着迷外，更多是忐忑不安，是仿徨，是迷茫，是真正的一无所有！ &emsp;&emsp;一行四人，也都在二月末分道扬镳。郭学军回家那边去做销售，我看好他，97年的，成熟，老练，社会方面比我强很多，用心交流过；“赵日天”继续留着，有着别人都没有过的经历，从他身上看到了儿时伙伴们的影子；姓龙的家伙99年的，应该还在外婆家包着水晶饺，蒸着杭州小笼包；另一个名字忘了，是个大专生，有心机，挺长的小巧帅气，估计也回家了！在杭州一块住了一个多月，脑海里还会记得“邓金华”，“日天”，“赵日地”，“外婆家”，“茶香鸡”，“雪媚娘”，“葵巷社区”，“203”，“西湖银泰”……这些名词。现在想想，仿佛就在昨天，又感觉很远很远。 &emsp;&emsp;“生活中，要学会吃亏，吃亏是福”，外婆家西湖银泰店经理如是说； &emsp;&emsp;“说话要注意分寸，与人交际，谨言为善，遇事三思而后行”，两次（第一次，和中介沟通报销车票；第二次，和家教中介沟通安排家教）吵架后的教训； ​&emsp;&emsp;“从心出发，努力学习，低调做人，谨言慎行，成熟稳重，闭眼狂奔！”，对自己如是说！","categories":[{"name":"LifeStyle","slug":"LifeStyle","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/"},{"name":"随笔","slug":"LifeStyle/随笔","permalink":"https://sophoraflower.github.io/EverQuest/categories/LifeStyle/随笔/"}],"tags":[]}]}